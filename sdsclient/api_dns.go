/*
 * SOLIDserver API
 *
 * OpenAPI 3.0.2 API definition for SOLIDserver service from EfficientIP.<p>Copyright Â© 2000-2021 EfficientIP</p><p><em>All specifications and information regarding the products in  this document are subject to change without notice and should not be  construed as a commitment by EfficientIP. EfficientIP assumes no  responsibility or liability for any mistakes or inaccuracies that may appear  in this document. All statements and recommendations in this document are  believed to be accurate but are presented without warranty. Users must take  full responsibility for their application of any product.</em></p><p>Generated (Monday 14th of June 2021 12:30:34 PM)</p>
 *
 * API version: 2.0
 * Contact: support-api@efficientip.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdsclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// DnsApiService DnsApi service
type DnsApiService service

type ApiDnsAclAddRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsAclAddInput *DnsAclAddInput
}

func (r ApiDnsAclAddRequest) DnsAclAddInput(dnsAclAddInput DnsAclAddInput) ApiDnsAclAddRequest {
	r.dnsAclAddInput = &dnsAclAddInput
	return r
}

func (r ApiDnsAclAddRequest) Execute() (DnsAclAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsAclAddExecute(r)
}

/*
 * DnsAclAdd Add a DNS ACL
 * This service allows to add objects. A call can only add one object. To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: ((acl_name  && (server_id || server_name || server_hostaddr)) && acl_value)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsAclAddRequest
 */
func (a *DnsApiService) DnsAclAdd(ctx _context.Context) ApiDnsAclAddRequest {
	return ApiDnsAclAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsAclAddSuccess
 */
func (a *DnsApiService) DnsAclAddExecute(r ApiDnsAclAddRequest) (DnsAclAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsAclAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsAclAdd")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/acl/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsAclAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsAclAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsAclCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
}

func (r ApiDnsAclCountRequest) Where(where string) ApiDnsAclCountRequest {
	r.where = &where
	return r
}

func (r ApiDnsAclCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsAclCountExecute(r)
}

/*
 * DnsAclCount Count the number of DNS ACLs
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsAclCountRequest
 */
func (a *DnsApiService) DnsAclCount(ctx _context.Context) ApiDnsAclCountRequest {
	return ApiDnsAclCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsAclCountExecute(r ApiDnsAclCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsAclCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/acl/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsAclDeleteRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	aclId *int32
	serverId *int32
	serverName *string
	aclName *string
	serverHostaddr *string
	warnings *string
}

func (r ApiDnsAclDeleteRequest) AclId(aclId int32) ApiDnsAclDeleteRequest {
	r.aclId = &aclId
	return r
}
func (r ApiDnsAclDeleteRequest) ServerId(serverId int32) ApiDnsAclDeleteRequest {
	r.serverId = &serverId
	return r
}
func (r ApiDnsAclDeleteRequest) ServerName(serverName string) ApiDnsAclDeleteRequest {
	r.serverName = &serverName
	return r
}
func (r ApiDnsAclDeleteRequest) AclName(aclName string) ApiDnsAclDeleteRequest {
	r.aclName = &aclName
	return r
}
func (r ApiDnsAclDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsAclDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}
func (r ApiDnsAclDeleteRequest) Warnings(warnings string) ApiDnsAclDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsAclDeleteRequest) Execute() (DnsAclDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsAclDeleteExecute(r)
}

/*
 * DnsAclDelete Delete a DNS ACL
 * This service allows to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: acl_id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsAclDeleteRequest
 */
func (a *DnsApiService) DnsAclDelete(ctx _context.Context) ApiDnsAclDeleteRequest {
	return ApiDnsAclDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsAclDeleteSuccess
 */
func (a *DnsApiService) DnsAclDeleteExecute(r ApiDnsAclDeleteRequest) (DnsAclDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsAclDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsAclDelete")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/acl/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.aclId != nil {
		localVarQueryParams.Add("acl_id", parameterToString(*r.aclId, ""))
	}
	if r.serverId != nil {
		localVarQueryParams.Add("server_id", parameterToString(*r.serverId, ""))
	}
	if r.serverName != nil {
		localVarQueryParams.Add("server_name", parameterToString(*r.serverName, ""))
	}
	if r.aclName != nil {
		localVarQueryParams.Add("acl_name", parameterToString(*r.aclName, ""))
	}
	if r.serverHostaddr != nil {
		localVarQueryParams.Add("server_hostaddr", parameterToString(*r.serverHostaddr, ""))
	}
	if r.warnings != nil {
		localVarQueryParams.Add("warnings", parameterToString(*r.warnings, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsAclDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsAclEditRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsAclEditInput *DnsAclEditInput
}

func (r ApiDnsAclEditRequest) DnsAclEditInput(dnsAclEditInput DnsAclEditInput) ApiDnsAclEditRequest {
	r.dnsAclEditInput = &dnsAclEditInput
	return r
}

func (r ApiDnsAclEditRequest) Execute() (DnsAclEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsAclEditExecute(r)
}

/*
 * DnsAclEdit Edit a DNS ACL
 * This service allows to edit existing objects using their identifier. All the input parameters and their value specified in input edit the identified object, any parameter not specified is left unchanged. A call can only edit one object.  To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: ((acl_id || (acl_name && (server_id || server_name || server_hostaddr))) && acl_value)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsAclEditRequest
 */
func (a *DnsApiService) DnsAclEdit(ctx _context.Context) ApiDnsAclEditRequest {
	return ApiDnsAclEditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsAclEditSuccess
 */
func (a *DnsApiService) DnsAclEditExecute(r ApiDnsAclEditRequest) (DnsAclEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsAclEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsAclEdit")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/acl/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsAclEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsAclEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsAclInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	aclId *int32
}

func (r ApiDnsAclInfoRequest) AclId(aclId int32) ApiDnsAclInfoRequest {
	r.aclId = &aclId
	return r
}

func (r ApiDnsAclInfoRequest) Execute() (DnsAclData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsAclInfoExecute(r)
}

/*
 * DnsAclInfo Display the properties of a DNS ACL
 * This service allows to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsAclInfoRequest
 */
func (a *DnsApiService) DnsAclInfo(ctx _context.Context) ApiDnsAclInfoRequest {
	return ApiDnsAclInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsAclData
 */
func (a *DnsApiService) DnsAclInfoExecute(r ApiDnsAclInfoRequest) (DnsAclData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsAclData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsAclInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/acl/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.aclId != nil {
		localVarQueryParams.Add("acl_id", parameterToString(*r.aclId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsAclListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
}

func (r ApiDnsAclListRequest) Orderby(orderby string) ApiDnsAclListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsAclListRequest) Where(where string) ApiDnsAclListRequest {
	r.where = &where
	return r
}
func (r ApiDnsAclListRequest) Limit(limit int32) ApiDnsAclListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsAclListRequest) Offset(offset int32) ApiDnsAclListRequest {
	r.offset = &offset
	return r
}

func (r ApiDnsAclListRequest) Execute() (DnsAclData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsAclListExecute(r)
}

/*
 * DnsAclList List the DNS ACLs
 * This service allows to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsAclListRequest
 */
func (a *DnsApiService) DnsAclList(ctx _context.Context) ApiDnsAclListRequest {
	return ApiDnsAclListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsAclData
 */
func (a *DnsApiService) DnsAclListExecute(r ApiDnsAclListRequest) (DnsAclData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsAclData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsAclList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/acl/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsRrAddRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsRrAddInput *DnsRrAddInput
}

func (r ApiDnsRrAddRequest) DnsRrAddInput(dnsRrAddInput DnsRrAddInput) ApiDnsRrAddRequest {
	r.dnsRrAddInput = &dnsRrAddInput
	return r
}

func (r ApiDnsRrAddRequest) Execute() (DnsRrAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsRrAddExecute(r)
}

/*
 * DnsRrAdd Add a resource record
 * This service allows to add a resource record or edit an existing one.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.<br/>Adding some resource records requires to specify one or more values:<table><caption>Expected values for the DNS records</caption><br/><thead><tr><th>Type</th><th>Value number</th><th>Related field(s)</th><th>Syntax</th></tr><br/></thead><br/><tbody><tr><td rowspan='7'>SOA</td><td >1</td><td >Name server</td><td >Type in the FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.</td></tr><tr><td >2</td><td >Responsible</td><td >Type in the administrator email address for the zone the record belongs to.</td></tr><tr><td >3</td><td >Serial number</td><td >Type in the serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.</td></tr><tr><td >4</td><td >Refresh</td><td >Type in the refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.</td></tr><tr><td >5</td><td >Retry</td><td >Type in the retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.</td></tr><tr><td >6</td><td >Expiration</td><td >Type in the expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.</td></tr><tr><td >7</td><td >Minimum</td><td >Type in the minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.</td></tr><tr><td >NS</td><td >1</td><td >DNS server</td><td >Type in the DNS server hostname.</td></tr><tr><td rowspan='2'>MX</td><td >1</td><td >Preference</td><td >Type a number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Mail server</td><td >Type in the SMTP (mail) server hostname.</td></tr><tr><td >A</td><td >1</td><td >IP address</td><td >Type in the IPv4 Address of the host.</td></tr><tr><td >AAAA</td><td >1</td><td >IPv6 address</td><td >Type in the IPv6 Address of the host.</td></tr><tr><td >PTR</td><td >1</td><td >Localization</td><td >Type in the hostname that should be returned when the IP address is queried.</td></tr><tr><td >CNAME</td><td >1</td><td >Hostname</td><td >Type in the hostname.</td></tr><tr><td >TXT</td><td >1</td><td >Text</td><td >Type in the description of your choice (max. 255 characters including spaces).</td></tr><tr><td rowspan='4'>SRV</td><td >1</td><td >Priority</td><td >Type a number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Weight</td><td >Type a number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in 0, there is no weighting.</td></tr><tr><td >3</td><td >Ports</td><td >Type in the port number that delivers the service to the target.</td></tr><tr><td >4</td><td >Target</td><td >Type in the hostname of the server delivering the service.</td></tr><tr><td rowspan='2'>HINFO</td><td >1</td><td >CPU</td><td >Type in the name of the CPU, either , , , , , , ,  or .</td></tr><tr><td >2</td><td >OS</td><td >The name of the operating system, either , , , , , , , , , , , or .</td></tr><tr><td rowspan='2'>MINFO</td><td >1</td><td >Responsible email</td><td >Type in the email address of the administrator of the mail list.</td></tr><tr><td >2</td><td >Error email</td><td >Type in the email address that should receive the error messages regarding the mail list.</td></tr><tr><td >DNAME</td><td >1</td><td >Domain</td><td >Type in the domain name of a subdomain of the zone.</td></tr><tr><td rowspan='2'>AFSDB</td><td >1</td><td >Preference</td><td >Type the version of AFS service used:  (AFS version 3.0) or  (OSF DCE/NCA version).</td></tr><tr><td >2</td><td >AFS server</td><td >Type in the AFS hostname.</td></tr><tr><td rowspan='6'>NAPTR</td><td >1</td><td >Order</td><td >Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Preference</td><td >Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Flags</td><td >Type in the string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field ,  and/or .</td></tr><tr><td >3</td><td >Services</td><td >Type in the services parameters to which applies the action specified in the field . You must respect your client application syntax.</td></tr><tr><td >4</td><td >Regex</td><td >Type in the string that contains a substitution expression matching the format  to which applies the action specified the field .</td></tr><tr><td >5</td><td >Replace</td><td >Type in an FQDN domain name to which applies the action specified the field . You can specify no domain name if you type in  (dot) in the field.</td></tr><tr><td >NSAP</td><td >1</td><td >Name</td><td >Type in the NSAP address of the end system. It should start with  and not exceed 255 hexadecimal characters separated by dots.</td></tr><tr><td rowspan='4'>DS</td><td >1</td><td >Key Tag</td><td >Type in the parent zone DS key tag.</td></tr><tr><td >2</td><td >Key Algorithm</td><td >Type in the parent zone DS algorithm key.</td></tr><tr><td >3</td><td >Digest Type</td><td >Type in the parent zone DS digest type.</td></tr><tr><td >4</td><td >Digest</td><td >Type in the parent zone DS digest.</td></tr><tr><td rowspan='4'>DNSKEY</td><td >1</td><td >Flags</td><td >Type in or paste the zone key flag.</td></tr><tr><td >2</td><td >Protocol</td><td >Type in or paste the protocol value.</td></tr><tr><td >3</td><td >Algorithm</td><td >Type in or paste the public key's cryptographic algorithm.</td></tr><tr><td >4</td><td >Key</td><td >Type in or paste the public key material.</td></tr><tr><td rowspan='3'>WKS</td><td >1</td><td >IP address</td><td >Type in the IPv4 Address of the host that contains the services listed in the Services field.</td></tr><tr><td >2</td><td >Protocol</td><td >Type in  or .</td></tr><tr><td >3</td><td >Services</td><td >Type in the list of needed services.</td></tr></tbody></table></p><br/></br></br><b>Mandatory Parameters</b>: (rr_name && rr_type && rr_value1 && (server_id || server_name || server_hostaddr))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsRrAddRequest
 */
func (a *DnsApiService) DnsRrAdd(ctx _context.Context) ApiDnsRrAddRequest {
	return ApiDnsRrAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsRrAddSuccess
 */
func (a *DnsApiService) DnsRrAddExecute(r ApiDnsRrAddRequest) (DnsRrAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsRrAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsRrAdd")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/rr/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsRrAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsRrAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsRrCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
	tags *string
}

func (r ApiDnsRrCountRequest) Where(where string) ApiDnsRrCountRequest {
	r.where = &where
	return r
}
func (r ApiDnsRrCountRequest) Tags(tags string) ApiDnsRrCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsRrCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsRrCountExecute(r)
}

/*
 * DnsRrCount Count the number of resource records
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsRrCountRequest
 */
func (a *DnsApiService) DnsRrCount(ctx _context.Context) ApiDnsRrCountRequest {
	return ApiDnsRrCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsRrCountExecute(r ApiDnsRrCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsRrCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/rr/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsRrDeleteRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	serverId *int32
	serverName *string
	zoneId *int32
	zoneName *string
	serverHostaddr *string
	rrId *int32
	rrName *string
	viewId *int32
	viewName *string
	zoneSpaceId *int32
	rrType *string
	rrValue1 *string
	rrValue2 *string
	rrValue3 *string
	rrValue4 *string
	rrValue5 *string
	rrValue6 *string
	rrValue7 *string
	warnings *string
}

func (r ApiDnsRrDeleteRequest) ServerId(serverId int32) ApiDnsRrDeleteRequest {
	r.serverId = &serverId
	return r
}
func (r ApiDnsRrDeleteRequest) ServerName(serverName string) ApiDnsRrDeleteRequest {
	r.serverName = &serverName
	return r
}
func (r ApiDnsRrDeleteRequest) ZoneId(zoneId int32) ApiDnsRrDeleteRequest {
	r.zoneId = &zoneId
	return r
}
func (r ApiDnsRrDeleteRequest) ZoneName(zoneName string) ApiDnsRrDeleteRequest {
	r.zoneName = &zoneName
	return r
}
func (r ApiDnsRrDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsRrDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}
func (r ApiDnsRrDeleteRequest) RrId(rrId int32) ApiDnsRrDeleteRequest {
	r.rrId = &rrId
	return r
}
func (r ApiDnsRrDeleteRequest) RrName(rrName string) ApiDnsRrDeleteRequest {
	r.rrName = &rrName
	return r
}
func (r ApiDnsRrDeleteRequest) ViewId(viewId int32) ApiDnsRrDeleteRequest {
	r.viewId = &viewId
	return r
}
func (r ApiDnsRrDeleteRequest) ViewName(viewName string) ApiDnsRrDeleteRequest {
	r.viewName = &viewName
	return r
}
func (r ApiDnsRrDeleteRequest) ZoneSpaceId(zoneSpaceId int32) ApiDnsRrDeleteRequest {
	r.zoneSpaceId = &zoneSpaceId
	return r
}
func (r ApiDnsRrDeleteRequest) RrType(rrType string) ApiDnsRrDeleteRequest {
	r.rrType = &rrType
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue1(rrValue1 string) ApiDnsRrDeleteRequest {
	r.rrValue1 = &rrValue1
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue2(rrValue2 string) ApiDnsRrDeleteRequest {
	r.rrValue2 = &rrValue2
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue3(rrValue3 string) ApiDnsRrDeleteRequest {
	r.rrValue3 = &rrValue3
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue4(rrValue4 string) ApiDnsRrDeleteRequest {
	r.rrValue4 = &rrValue4
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue5(rrValue5 string) ApiDnsRrDeleteRequest {
	r.rrValue5 = &rrValue5
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue6(rrValue6 string) ApiDnsRrDeleteRequest {
	r.rrValue6 = &rrValue6
	return r
}
func (r ApiDnsRrDeleteRequest) RrValue7(rrValue7 string) ApiDnsRrDeleteRequest {
	r.rrValue7 = &rrValue7
	return r
}
func (r ApiDnsRrDeleteRequest) Warnings(warnings string) ApiDnsRrDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsRrDeleteRequest) Execute() (DnsRrDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsRrDeleteExecute(r)
}

/*
 * DnsRrDelete Delete a resource record
 * This service allows to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (rr_id || (rr_name && (zone_id || (zone_name && (server_id || server_name || server_hostaddr)))))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsRrDeleteRequest
 */
func (a *DnsApiService) DnsRrDelete(ctx _context.Context) ApiDnsRrDeleteRequest {
	return ApiDnsRrDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsRrDeleteSuccess
 */
func (a *DnsApiService) DnsRrDeleteExecute(r ApiDnsRrDeleteRequest) (DnsRrDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsRrDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsRrDelete")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/rr/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.serverId != nil {
		localVarQueryParams.Add("server_id", parameterToString(*r.serverId, ""))
	}
	if r.serverName != nil {
		localVarQueryParams.Add("server_name", parameterToString(*r.serverName, ""))
	}
	if r.zoneId != nil {
		localVarQueryParams.Add("zone_id", parameterToString(*r.zoneId, ""))
	}
	if r.zoneName != nil {
		localVarQueryParams.Add("zone_name", parameterToString(*r.zoneName, ""))
	}
	if r.serverHostaddr != nil {
		localVarQueryParams.Add("server_hostaddr", parameterToString(*r.serverHostaddr, ""))
	}
	if r.rrId != nil {
		localVarQueryParams.Add("rr_id", parameterToString(*r.rrId, ""))
	}
	if r.rrName != nil {
		localVarQueryParams.Add("rr_name", parameterToString(*r.rrName, ""))
	}
	if r.viewId != nil {
		localVarQueryParams.Add("view_id", parameterToString(*r.viewId, ""))
	}
	if r.viewName != nil {
		localVarQueryParams.Add("view_name", parameterToString(*r.viewName, ""))
	}
	if r.zoneSpaceId != nil {
		localVarQueryParams.Add("zone_space_id", parameterToString(*r.zoneSpaceId, ""))
	}
	if r.rrType != nil {
		localVarQueryParams.Add("rr_type", parameterToString(*r.rrType, ""))
	}
	if r.rrValue1 != nil {
		localVarQueryParams.Add("rr_value1", parameterToString(*r.rrValue1, ""))
	}
	if r.rrValue2 != nil {
		localVarQueryParams.Add("rr_value2", parameterToString(*r.rrValue2, ""))
	}
	if r.rrValue3 != nil {
		localVarQueryParams.Add("rr_value3", parameterToString(*r.rrValue3, ""))
	}
	if r.rrValue4 != nil {
		localVarQueryParams.Add("rr_value4", parameterToString(*r.rrValue4, ""))
	}
	if r.rrValue5 != nil {
		localVarQueryParams.Add("rr_value5", parameterToString(*r.rrValue5, ""))
	}
	if r.rrValue6 != nil {
		localVarQueryParams.Add("rr_value6", parameterToString(*r.rrValue6, ""))
	}
	if r.rrValue7 != nil {
		localVarQueryParams.Add("rr_value7", parameterToString(*r.rrValue7, ""))
	}
	if r.warnings != nil {
		localVarQueryParams.Add("warnings", parameterToString(*r.warnings, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsRrDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsRrEditRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsRrEditInput *DnsRrEditInput
}

func (r ApiDnsRrEditRequest) DnsRrEditInput(dnsRrEditInput DnsRrEditInput) ApiDnsRrEditRequest {
	r.dnsRrEditInput = &dnsRrEditInput
	return r
}

func (r ApiDnsRrEditRequest) Execute() (DnsRrEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsRrEditExecute(r)
}

/*
 * DnsRrEdit Edit a resource record
 * This service allows to add a resource record or edit an existing one.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.<br/>Adding some resource records requires to specify one or more values:<table><caption>Expected values for the DNS records</caption><br/><thead><tr><th>Type</th><th>Value number</th><th>Related field(s)</th><th>Syntax</th></tr><br/></thead><br/><tbody><tr><td rowspan='7'>SOA</td><td >1</td><td >Name server</td><td >Type in the FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.</td></tr><tr><td >2</td><td >Responsible</td><td >Type in the administrator email address for the zone the record belongs to.</td></tr><tr><td >3</td><td >Serial number</td><td >Type in the serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.</td></tr><tr><td >4</td><td >Refresh</td><td >Type in the refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.</td></tr><tr><td >5</td><td >Retry</td><td >Type in the retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.</td></tr><tr><td >6</td><td >Expiration</td><td >Type in the expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.</td></tr><tr><td >7</td><td >Minimum</td><td >Type in the minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.</td></tr><tr><td >NS</td><td >1</td><td >DNS server</td><td >Type in the DNS server hostname.</td></tr><tr><td rowspan='2'>MX</td><td >1</td><td >Preference</td><td >Type a number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Mail server</td><td >Type in the SMTP (mail) server hostname.</td></tr><tr><td >A</td><td >1</td><td >IP address</td><td >Type in the IPv4 Address of the host.</td></tr><tr><td >AAAA</td><td >1</td><td >IPv6 address</td><td >Type in the IPv6 Address of the host.</td></tr><tr><td >PTR</td><td >1</td><td >Localization</td><td >Type in the hostname that should be returned when the IP address is queried.</td></tr><tr><td >CNAME</td><td >1</td><td >Hostname</td><td >Type in the hostname.</td></tr><tr><td >TXT</td><td >1</td><td >Text</td><td >Type in the description of your choice (max. 255 characters including spaces).</td></tr><tr><td rowspan='4'>SRV</td><td >1</td><td >Priority</td><td >Type a number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Weight</td><td >Type a number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in 0, there is no weighting.</td></tr><tr><td >3</td><td >Ports</td><td >Type in the port number that delivers the service to the target.</td></tr><tr><td >4</td><td >Target</td><td >Type in the hostname of the server delivering the service.</td></tr><tr><td rowspan='2'>HINFO</td><td >1</td><td >CPU</td><td >Type in the name of the CPU, either , , , , , , ,  or .</td></tr><tr><td >2</td><td >OS</td><td >The name of the operating system, either , , , , , , , , , , , or .</td></tr><tr><td rowspan='2'>MINFO</td><td >1</td><td >Responsible email</td><td >Type in the email address of the administrator of the mail list.</td></tr><tr><td >2</td><td >Error email</td><td >Type in the email address that should receive the error messages regarding the mail list.</td></tr><tr><td >DNAME</td><td >1</td><td >Domain</td><td >Type in the domain name of a subdomain of the zone.</td></tr><tr><td rowspan='2'>AFSDB</td><td >1</td><td >Preference</td><td >Type the version of AFS service used:  (AFS version 3.0) or  (OSF DCE/NCA version).</td></tr><tr><td >2</td><td >AFS server</td><td >Type in the AFS hostname.</td></tr><tr><td rowspan='6'>NAPTR</td><td >1</td><td >Order</td><td >Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Preference</td><td >Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Flags</td><td >Type in the string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field ,  and/or .</td></tr><tr><td >3</td><td >Services</td><td >Type in the services parameters to which applies the action specified in the field . You must respect your client application syntax.</td></tr><tr><td >4</td><td >Regex</td><td >Type in the string that contains a substitution expression matching the format  to which applies the action specified the field .</td></tr><tr><td >5</td><td >Replace</td><td >Type in an FQDN domain name to which applies the action specified the field . You can specify no domain name if you type in  (dot) in the field.</td></tr><tr><td >NSAP</td><td >1</td><td >Name</td><td >Type in the NSAP address of the end system. It should start with  and not exceed 255 hexadecimal characters separated by dots.</td></tr><tr><td rowspan='4'>DS</td><td >1</td><td >Key Tag</td><td >Type in the parent zone DS key tag.</td></tr><tr><td >2</td><td >Key Algorithm</td><td >Type in the parent zone DS algorithm key.</td></tr><tr><td >3</td><td >Digest Type</td><td >Type in the parent zone DS digest type.</td></tr><tr><td >4</td><td >Digest</td><td >Type in the parent zone DS digest.</td></tr><tr><td rowspan='4'>DNSKEY</td><td >1</td><td >Flags</td><td >Type in or paste the zone key flag.</td></tr><tr><td >2</td><td >Protocol</td><td >Type in or paste the protocol value.</td></tr><tr><td >3</td><td >Algorithm</td><td >Type in or paste the public key's cryptographic algorithm.</td></tr><tr><td >4</td><td >Key</td><td >Type in or paste the public key material.</td></tr><tr><td rowspan='3'>WKS</td><td >1</td><td >IP address</td><td >Type in the IPv4 Address of the host that contains the services listed in the Services field.</td></tr><tr><td >2</td><td >Protocol</td><td >Type in  or .</td></tr><tr><td >3</td><td >Services</td><td >Type in the list of needed services.</td></tr></tbody></table></p><br/></br></br><b>Mandatory Parameters</b>: (rr_id || (rr_name && rr_type && rr_value1 && (server_id || server_name || server_hostaddr)))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsRrEditRequest
 */
func (a *DnsApiService) DnsRrEdit(ctx _context.Context) ApiDnsRrEditRequest {
	return ApiDnsRrEditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsRrEditSuccess
 */
func (a *DnsApiService) DnsRrEditExecute(r ApiDnsRrEditRequest) (DnsRrEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsRrEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsRrEdit")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/rr/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsRrEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsRrEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsRrInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	rrId *int32
}

func (r ApiDnsRrInfoRequest) RrId(rrId int32) ApiDnsRrInfoRequest {
	r.rrId = &rrId
	return r
}

func (r ApiDnsRrInfoRequest) Execute() (DnsRrData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsRrInfoExecute(r)
}

/*
 * DnsRrInfo Display the properties of a resource record
 * This service allows to display the properties of a resource record.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.Adding some resource records requires to specify one or more values:<br/>                                Expected values for the DNS records<br/>                                <br/>                                    <br/>                                    <br/>                                    <br/>                                    <br/>                                    <br/>                                        <br/>                                            Type<br/>                                            Value number<br/>                                            Related field(s)<br/>                                            Syntax<br/>                                        <br/>                                    <br/>                                    <br/>                                        <br/>                                            SOA<br/>                                            1<br/>                                            Name server<br/>                                            Type in the FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Responsible<br/>                                            Type in the administrator email address for the zone the record belongs to.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Serial number<br/>                                            Type in the serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Refresh<br/>                                            Type in the refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.<br/>                                        <br/>                                        <br/>                                            5<br/>                                            Retry<br/>                                            Type in the retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.<br/>                                        <br/>                                        <br/>                                            6<br/>                                            Expiration<br/>                                            Type in the expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.<br/>                                        <br/>                                        <br/>                                            7<br/>                                            Minimum<br/>                                            Type in the minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.<br/>                                        <br/>                                        <br/>                                            NS<br/>                                            1<br/>                                            DNS server<br/>                                            Type in the DNS server hostname.<br/>                                        <br/>                                        <br/>                                            MX<br/>                                            1<br/>                                            Preference<br/>                                            Type a number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Mail server<br/>                                            Type in the SMTP (mail) server hostname.<br/>                                        <br/>                                        <br/>                                            A<br/>                                            1<br/>                                            IP address<br/>                                            Type in the IPv4 Address of the host.<br/>                                        <br/>                                        <br/>                                            AAAA<br/>                                            1<br/>                                            IPv6 address<br/>                                            Type in the IPv6 Address of the host.<br/>                                        <br/>                                        <br/>                                            PTR<br/>                                            1<br/>                                            Localization<br/>                                            Type in the hostname that should be returned when the IP address is queried.<br/>                                        <br/>                                        <br/>                                            CNAME<br/>                                            1<br/>                                            Hostname<br/>                                            Type in the hostname.<br/>                                        <br/>                                        <br/>                                            TXT<br/>                                            1<br/>                                            Text<br/>                                            Type in the description of your choice (max. 255 characters including spaces).<br/>                                        <br/>                                        <br/>                                            SRV<br/>                                            1<br/>                                            Priority<br/>                                            Type a number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Weight<br/>                                            Type a number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in 0, there is no weighting.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Ports<br/>                                            Type in the port number that delivers the service to the target.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Target<br/>                                            Type in the hostname of the server delivering the service.<br/>                                        <br/>                                        <br/>                                            HINFO<br/>                                            1<br/>                                            CPU<br/>                                            Type in the name of the CPU, either INTEL, AMD, SPARC, ALPHA, HPPA, POWERPC, MIPS, MOTOROLA or Other.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            OS<br/>                                            The name of the operating system, either AIX, FREEBSD, HPUX, IRIX, LINUX, OSF, OS/2, SOLARIS, SUNOS, VMS, WINDOWS, or Other.<br/>                                        <br/>                                        <br/>                                            MINFO<br/>                                            1<br/>                                            Responsible email<br/>                                            Type in the email address of the administrator of the mail list.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Error email<br/>                                            Type in the email address that should receive the error messages regarding the mail list.<br/>                                        <br/>                                        <br/>                                            DNAME<br/>                                            1<br/>                                            Domain<br/>                                            Type in the domain name of a subdomain of the zone.<br/>                                        <br/>                                        <br/>                                            AFSDB<br/>                                            1<br/>                                            Preference<br/>                                            Type the version of AFS service used: 1 (AFS version 3.0) or 2 (OSF DCE/NCA version).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            AFS server<br/>                                            Type in the AFS hostname.<br/>                                        <br/>                                        <br/>                                            NAPTR<br/>                                                    The record NAPTR is described in the RFC 3403, available on IETF website: http://tools.ietf.org/html/rfc3403.<br/>                                                <br/>                                            1<br/>                                            Order<br/>                                            Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Preference<br/>                                            Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Flags<br/>                                            Type in the string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field Services, Regex and/or Replace.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Services<br/>                                            Type in the services parameters to which applies the action specified in the field Flags. You must respect your client application syntax.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Regex<br/>                                            Type in the string that contains a substitution expression matching the format <delimit ereg delimit substitution delimit flag> to which applies the action specified the field Flags.<br/>                                        <br/>                                        <br/>                                            5<br/>                                            Replace<br/>                                            Type in an FQDN domain name to which applies the action specified the field Flags. You can specify no domain name if you type in . (dot) in the field.<br/>                                        <br/>                                        <br/>                                            NSAP<br/>                                            1<br/>                                            Name<br/>                                            Type in the NSAP address of the end system. It should start with 0x and not exceed 255 hexadecimal characters separated by dots.<br/>                                        <br/>                                        <br/>                                            DS<br/>                                            1<br/>                                            Key Tag<br/>                                            Type in the parent zone DS key tag.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Key Algorithm<br/>                                            Type in the parent zone DS algorithm key.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Digest Type<br/>                                            Type in the parent zone DS digest type.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Digest<br/>                                            Type in the parent zone DS digest.<br/>                                        <br/>                                        <br/>                                            DNSKEY<br/>                                            1<br/>                                            Flags<br/>                                            Type in or paste the zone key flag.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Protocol<br/>                                            Type in or paste the protocol value.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Algorithm<br/>                                            Type in or paste the public key's cryptographic algorithm.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Key<br/>                                            Type in or paste the public key material.<br/>                                        <br/>                                        <br/>                                            WKS<br/>                                            1<br/>                                            IP address<br/>                                            Type in the IPv4 Address of the host that contains the services listed in the Services field.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Protocol<br/>                                            Type in TCP or UDP.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Services<br/>                                            Type in the list of needed services.<br/>                                        <br/>                                    <br/>                                <br/>                            
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsRrInfoRequest
 */
func (a *DnsApiService) DnsRrInfo(ctx _context.Context) ApiDnsRrInfoRequest {
	return ApiDnsRrInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsRrData
 */
func (a *DnsApiService) DnsRrInfoExecute(r ApiDnsRrInfoRequest) (DnsRrData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsRrData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsRrInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/rr/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rrId != nil {
		localVarQueryParams.Add("rr_id", parameterToString(*r.rrId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsRrListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
	tags *string
}

func (r ApiDnsRrListRequest) Orderby(orderby string) ApiDnsRrListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsRrListRequest) Where(where string) ApiDnsRrListRequest {
	r.where = &where
	return r
}
func (r ApiDnsRrListRequest) Limit(limit int32) ApiDnsRrListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsRrListRequest) Offset(offset int32) ApiDnsRrListRequest {
	r.offset = &offset
	return r
}
func (r ApiDnsRrListRequest) Tags(tags string) ApiDnsRrListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsRrListRequest) Execute() (DnsRrData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsRrListExecute(r)
}

/*
 * DnsRrList List the resource records
 * This service allows to list the resource records.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.<br/>Adding some resource records requires to specify one or more values:<table><caption>Expected values for the DNS records</caption><br/><thead><tr><th>Type</th><th>Value number</th><th>Related field(s)</th><th>Syntax</th></tr><br/></thead><br/><tbody><tr><td rowspan='7'>SOA</td><td >1</td><td >Name server</td><td >Type in the FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.</td></tr><tr><td >2</td><td >Responsible</td><td >Type in the administrator email address for the zone the record belongs to.</td></tr><tr><td >3</td><td >Serial number</td><td >Type in the serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.</td></tr><tr><td >4</td><td >Refresh</td><td >Type in the refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.</td></tr><tr><td >5</td><td >Retry</td><td >Type in the retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.</td></tr><tr><td >6</td><td >Expiration</td><td >Type in the expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.</td></tr><tr><td >7</td><td >Minimum</td><td >Type in the minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.</td></tr><tr><td >NS</td><td >1</td><td >DNS server</td><td >Type in the DNS server hostname.</td></tr><tr><td rowspan='2'>MX</td><td >1</td><td >Preference</td><td >Type a number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Mail server</td><td >Type in the SMTP (mail) server hostname.</td></tr><tr><td >A</td><td >1</td><td >IP address</td><td >Type in the IPv4 Address of the host.</td></tr><tr><td >AAAA</td><td >1</td><td >IPv6 address</td><td >Type in the IPv6 Address of the host.</td></tr><tr><td >PTR</td><td >1</td><td >Localization</td><td >Type in the hostname that should be returned when the IP address is queried.</td></tr><tr><td >CNAME</td><td >1</td><td >Hostname</td><td >Type in the hostname.</td></tr><tr><td >TXT</td><td >1</td><td >Text</td><td >Type in the description of your choice (max. 255 characters including spaces).</td></tr><tr><td rowspan='4'>SRV</td><td >1</td><td >Priority</td><td >Type a number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Weight</td><td >Type a number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in 0, there is no weighting.</td></tr><tr><td >3</td><td >Ports</td><td >Type in the port number that delivers the service to the target.</td></tr><tr><td >4</td><td >Target</td><td >Type in the hostname of the server delivering the service.</td></tr><tr><td rowspan='2'>HINFO</td><td >1</td><td >CPU</td><td >Type in the name of the CPU, either , , , , , , ,  or .</td></tr><tr><td >2</td><td >OS</td><td >The name of the operating system, either , , , , , , , , , , , or .</td></tr><tr><td rowspan='2'>MINFO</td><td >1</td><td >Responsible email</td><td >Type in the email address of the administrator of the mail list.</td></tr><tr><td >2</td><td >Error email</td><td >Type in the email address that should receive the error messages regarding the mail list.</td></tr><tr><td >DNAME</td><td >1</td><td >Domain</td><td >Type in the domain name of a subdomain of the zone.</td></tr><tr><td rowspan='2'>AFSDB</td><td >1</td><td >Preference</td><td >Type the version of AFS service used:  (AFS version 3.0) or  (OSF DCE/NCA version).</td></tr><tr><td >2</td><td >AFS server</td><td >Type in the AFS hostname.</td></tr><tr><td rowspan='6'>NAPTR</td><td >1</td><td >Order</td><td >Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Preference</td><td >Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Flags</td><td >Type in the string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field ,  and/or .</td></tr><tr><td >3</td><td >Services</td><td >Type in the services parameters to which applies the action specified in the field . You must respect your client application syntax.</td></tr><tr><td >4</td><td >Regex</td><td >Type in the string that contains a substitution expression matching the format  to which applies the action specified the field .</td></tr><tr><td >5</td><td >Replace</td><td >Type in an FQDN domain name to which applies the action specified the field . You can specify no domain name if you type in  (dot) in the field.</td></tr><tr><td >NSAP</td><td >1</td><td >Name</td><td >Type in the NSAP address of the end system. It should start with  and not exceed 255 hexadecimal characters separated by dots.</td></tr><tr><td rowspan='4'>DS</td><td >1</td><td >Key Tag</td><td >Type in the parent zone DS key tag.</td></tr><tr><td >2</td><td >Key Algorithm</td><td >Type in the parent zone DS algorithm key.</td></tr><tr><td >3</td><td >Digest Type</td><td >Type in the parent zone DS digest type.</td></tr><tr><td >4</td><td >Digest</td><td >Type in the parent zone DS digest.</td></tr><tr><td rowspan='4'>DNSKEY</td><td >1</td><td >Flags</td><td >Type in or paste the zone key flag.</td></tr><tr><td >2</td><td >Protocol</td><td >Type in or paste the protocol value.</td></tr><tr><td >3</td><td >Algorithm</td><td >Type in or paste the public key's cryptographic algorithm.</td></tr><tr><td >4</td><td >Key</td><td >Type in or paste the public key material.</td></tr><tr><td rowspan='3'>WKS</td><td >1</td><td >IP address</td><td >Type in the IPv4 Address of the host that contains the services listed in the Services field.</td></tr><tr><td >2</td><td >Protocol</td><td >Type in  or .</td></tr><tr><td >3</td><td >Services</td><td >Type in the list of needed services.</td></tr></tbody></table></p><br/>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsRrListRequest
 */
func (a *DnsApiService) DnsRrList(ctx _context.Context) ApiDnsRrListRequest {
	return ApiDnsRrListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsRrData
 */
func (a *DnsApiService) DnsRrListExecute(r ApiDnsRrListRequest) (DnsRrData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsRrData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsRrList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/rr/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsServerCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
	tags *string
}

func (r ApiDnsServerCountRequest) Where(where string) ApiDnsServerCountRequest {
	r.where = &where
	return r
}
func (r ApiDnsServerCountRequest) Tags(tags string) ApiDnsServerCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsServerCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsServerCountExecute(r)
}

/*
 * DnsServerCount Count the number of DNS servers
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsServerCountRequest
 */
func (a *DnsApiService) DnsServerCount(ctx _context.Context) ApiDnsServerCountRequest {
	return ApiDnsServerCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsServerCountExecute(r ApiDnsServerCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsServerCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/server/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsServerInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	serverId *int32
}

func (r ApiDnsServerInfoRequest) ServerId(serverId int32) ApiDnsServerInfoRequest {
	r.serverId = &serverId
	return r
}

func (r ApiDnsServerInfoRequest) Execute() (DnsServerData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsServerInfoExecute(r)
}

/*
 * DnsServerInfo Display the properties of a DNS server
 * This service allows to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsServerInfoRequest
 */
func (a *DnsApiService) DnsServerInfo(ctx _context.Context) ApiDnsServerInfoRequest {
	return ApiDnsServerInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsServerData
 */
func (a *DnsApiService) DnsServerInfoExecute(r ApiDnsServerInfoRequest) (DnsServerData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsServerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsServerInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/server/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.serverId != nil {
		localVarQueryParams.Add("server_id", parameterToString(*r.serverId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsServerListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
	tags *string
}

func (r ApiDnsServerListRequest) Orderby(orderby string) ApiDnsServerListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsServerListRequest) Where(where string) ApiDnsServerListRequest {
	r.where = &where
	return r
}
func (r ApiDnsServerListRequest) Limit(limit int32) ApiDnsServerListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsServerListRequest) Offset(offset int32) ApiDnsServerListRequest {
	r.offset = &offset
	return r
}
func (r ApiDnsServerListRequest) Tags(tags string) ApiDnsServerListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsServerListRequest) Execute() (DnsServerData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsServerListExecute(r)
}

/*
 * DnsServerList List the DNS servers
 * This service allows to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsServerListRequest
 */
func (a *DnsApiService) DnsServerList(ctx _context.Context) ApiDnsServerListRequest {
	return ApiDnsServerListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsServerData
 */
func (a *DnsApiService) DnsServerListExecute(r ApiDnsServerListRequest) (DnsServerData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsServerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsServerList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/server/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewAddRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsViewAddInput *DnsViewAddInput
}

func (r ApiDnsViewAddRequest) DnsViewAddInput(dnsViewAddInput DnsViewAddInput) ApiDnsViewAddRequest {
	r.dnsViewAddInput = &dnsViewAddInput
	return r
}

func (r ApiDnsViewAddRequest) Execute() (DnsViewAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewAddExecute(r)
}

/*
 * DnsViewAdd Add a view
 * This service allows to add objects. A call can only add one object. To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_name && (server_id || server_name || server_hostaddr))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewAddRequest
 */
func (a *DnsApiService) DnsViewAdd(ctx _context.Context) ApiDnsViewAddRequest {
	return ApiDnsViewAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewAddSuccess
 */
func (a *DnsApiService) DnsViewAddExecute(r ApiDnsViewAddRequest) (DnsViewAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewAdd")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/view/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
	tags *string
}

func (r ApiDnsViewCountRequest) Where(where string) ApiDnsViewCountRequest {
	r.where = &where
	return r
}
func (r ApiDnsViewCountRequest) Tags(tags string) ApiDnsViewCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsViewCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewCountExecute(r)
}

/*
 * DnsViewCount Count the number of views
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewCountRequest
 */
func (a *DnsApiService) DnsViewCount(ctx _context.Context) ApiDnsViewCountRequest {
	return ApiDnsViewCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsViewCountExecute(r ApiDnsViewCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/view/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewDeleteRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	serverId *int32
	serverName *string
	viewId *int32
	viewName *string
	serverHostaddr *string
	warnings *string
}

func (r ApiDnsViewDeleteRequest) ServerId(serverId int32) ApiDnsViewDeleteRequest {
	r.serverId = &serverId
	return r
}
func (r ApiDnsViewDeleteRequest) ServerName(serverName string) ApiDnsViewDeleteRequest {
	r.serverName = &serverName
	return r
}
func (r ApiDnsViewDeleteRequest) ViewId(viewId int32) ApiDnsViewDeleteRequest {
	r.viewId = &viewId
	return r
}
func (r ApiDnsViewDeleteRequest) ViewName(viewName string) ApiDnsViewDeleteRequest {
	r.viewName = &viewName
	return r
}
func (r ApiDnsViewDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsViewDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}
func (r ApiDnsViewDeleteRequest) Warnings(warnings string) ApiDnsViewDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsViewDeleteRequest) Execute() (DnsViewDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewDeleteExecute(r)
}

/*
 * DnsViewDelete Delete a view
 * This service allows to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id || (view_name  && (server_id || server_name || server_hostaddr)))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewDeleteRequest
 */
func (a *DnsApiService) DnsViewDelete(ctx _context.Context) ApiDnsViewDeleteRequest {
	return ApiDnsViewDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewDeleteSuccess
 */
func (a *DnsApiService) DnsViewDeleteExecute(r ApiDnsViewDeleteRequest) (DnsViewDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewDelete")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/view/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.serverId != nil {
		localVarQueryParams.Add("server_id", parameterToString(*r.serverId, ""))
	}
	if r.serverName != nil {
		localVarQueryParams.Add("server_name", parameterToString(*r.serverName, ""))
	}
	if r.viewId != nil {
		localVarQueryParams.Add("view_id", parameterToString(*r.viewId, ""))
	}
	if r.viewName != nil {
		localVarQueryParams.Add("view_name", parameterToString(*r.viewName, ""))
	}
	if r.serverHostaddr != nil {
		localVarQueryParams.Add("server_hostaddr", parameterToString(*r.serverHostaddr, ""))
	}
	if r.warnings != nil {
		localVarQueryParams.Add("warnings", parameterToString(*r.warnings, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewEditRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsViewEditInput *DnsViewEditInput
}

func (r ApiDnsViewEditRequest) DnsViewEditInput(dnsViewEditInput DnsViewEditInput) ApiDnsViewEditRequest {
	r.dnsViewEditInput = &dnsViewEditInput
	return r
}

func (r ApiDnsViewEditRequest) Execute() (DnsViewEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewEditExecute(r)
}

/*
 * DnsViewEdit Edit a view
 * This service allows to edit existing objects using their identifier. All the input parameters and their value specified in input edit the identified object, any parameter not specified is left unchanged. A call can only edit one object.  To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id || (view_name && (server_id || server_name || server_hostaddr)))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewEditRequest
 */
func (a *DnsApiService) DnsViewEdit(ctx _context.Context) ApiDnsViewEditRequest {
	return ApiDnsViewEditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewEditSuccess
 */
func (a *DnsApiService) DnsViewEditExecute(r ApiDnsViewEditRequest) (DnsViewEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewEdit")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/view/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	viewId *int32
}

func (r ApiDnsViewInfoRequest) ViewId(viewId int32) ApiDnsViewInfoRequest {
	r.viewId = &viewId
	return r
}

func (r ApiDnsViewInfoRequest) Execute() (DnsViewData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewInfoExecute(r)
}

/*
 * DnsViewInfo Display the properties of a view
 * This service allows to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewInfoRequest
 */
func (a *DnsApiService) DnsViewInfo(ctx _context.Context) ApiDnsViewInfoRequest {
	return ApiDnsViewInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewData
 */
func (a *DnsApiService) DnsViewInfoExecute(r ApiDnsViewInfoRequest) (DnsViewData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/view/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.viewId != nil {
		localVarQueryParams.Add("view_id", parameterToString(*r.viewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
	tags *string
}

func (r ApiDnsViewListRequest) Orderby(orderby string) ApiDnsViewListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsViewListRequest) Where(where string) ApiDnsViewListRequest {
	r.where = &where
	return r
}
func (r ApiDnsViewListRequest) Limit(limit int32) ApiDnsViewListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsViewListRequest) Offset(offset int32) ApiDnsViewListRequest {
	r.offset = &offset
	return r
}
func (r ApiDnsViewListRequest) Tags(tags string) ApiDnsViewListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsViewListRequest) Execute() (DnsViewData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewListExecute(r)
}

/*
 * DnsViewList List the views
 * This service allows to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewListRequest
 */
func (a *DnsApiService) DnsViewList(ctx _context.Context) ApiDnsViewListRequest {
	return ApiDnsViewListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewData
 */
func (a *DnsApiService) DnsViewListExecute(r ApiDnsViewListRequest) (DnsViewData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/view/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewparamAddRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsViewparamAddInput *DnsViewparamAddInput
}

func (r ApiDnsViewparamAddRequest) DnsViewparamAddInput(dnsViewparamAddInput DnsViewparamAddInput) ApiDnsViewparamAddRequest {
	r.dnsViewparamAddInput = &dnsViewparamAddInput
	return r
}

func (r ApiDnsViewparamAddRequest) Execute() (DnsViewparamAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewparamAddExecute(r)
}

/*
 * DnsViewparamAdd Add a DNS option on a view
 * This service allows to add objects. A call can only add one object. To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id && viewparam_key)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewparamAddRequest
 */
func (a *DnsApiService) DnsViewparamAdd(ctx _context.Context) ApiDnsViewparamAddRequest {
	return ApiDnsViewparamAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewparamAddSuccess
 */
func (a *DnsApiService) DnsViewparamAddExecute(r ApiDnsViewparamAddRequest) (DnsViewparamAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewparamAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewparamAdd")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/viewparam/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewparamAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewparamAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewparamCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
}

func (r ApiDnsViewparamCountRequest) Where(where string) ApiDnsViewparamCountRequest {
	r.where = &where
	return r
}

func (r ApiDnsViewparamCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewparamCountExecute(r)
}

/*
 * DnsViewparamCount Count the number of DNS options of a view
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewparamCountRequest
 */
func (a *DnsApiService) DnsViewparamCount(ctx _context.Context) ApiDnsViewparamCountRequest {
	return ApiDnsViewparamCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsViewparamCountExecute(r ApiDnsViewparamCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewparamCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/viewparam/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewparamDeleteRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	viewId *int32
	viewparamKey *string
}

func (r ApiDnsViewparamDeleteRequest) ViewId(viewId int32) ApiDnsViewparamDeleteRequest {
	r.viewId = &viewId
	return r
}
func (r ApiDnsViewparamDeleteRequest) ViewparamKey(viewparamKey string) ApiDnsViewparamDeleteRequest {
	r.viewparamKey = &viewparamKey
	return r
}

func (r ApiDnsViewparamDeleteRequest) Execute() (DnsViewparamDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewparamDeleteExecute(r)
}

/*
 * DnsViewparamDelete Delete a DNS option from a view
 * This service allows to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id && viewparam_key)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewparamDeleteRequest
 */
func (a *DnsApiService) DnsViewparamDelete(ctx _context.Context) ApiDnsViewparamDeleteRequest {
	return ApiDnsViewparamDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewparamDeleteSuccess
 */
func (a *DnsApiService) DnsViewparamDeleteExecute(r ApiDnsViewparamDeleteRequest) (DnsViewparamDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewparamDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewparamDelete")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/viewparam/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.viewId != nil {
		localVarQueryParams.Add("view_id", parameterToString(*r.viewId, ""))
	}
	if r.viewparamKey != nil {
		localVarQueryParams.Add("viewparam_key", parameterToString(*r.viewparamKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewparamDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewparamEditRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsViewparamEditInput *DnsViewparamEditInput
}

func (r ApiDnsViewparamEditRequest) DnsViewparamEditInput(dnsViewparamEditInput DnsViewparamEditInput) ApiDnsViewparamEditRequest {
	r.dnsViewparamEditInput = &dnsViewparamEditInput
	return r
}

func (r ApiDnsViewparamEditRequest) Execute() (DnsViewparamEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewparamEditExecute(r)
}

/*
 * DnsViewparamEdit Edit a DNS option on a view
 * This service allows to edit existing objects using their identifier. All the input parameters and their value specified in input edit the identified object, any parameter not specified is left unchanged. A call can only edit one object.  To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id && viewparam_key)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewparamEditRequest
 */
func (a *DnsApiService) DnsViewparamEdit(ctx _context.Context) ApiDnsViewparamEditRequest {
	return ApiDnsViewparamEditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewparamEditSuccess
 */
func (a *DnsApiService) DnsViewparamEditExecute(r ApiDnsViewparamEditRequest) (DnsViewparamEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewparamEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewparamEdit")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/viewparam/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewparamEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewparamEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewparamInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	viewId *int32
}

func (r ApiDnsViewparamInfoRequest) ViewId(viewId int32) ApiDnsViewparamInfoRequest {
	r.viewId = &viewId
	return r
}

func (r ApiDnsViewparamInfoRequest) Execute() (DnsViewparamData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewparamInfoExecute(r)
}

/*
 * DnsViewparamInfo Display the properties of a DNS option set on a view
 * This service allows to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewparamInfoRequest
 */
func (a *DnsApiService) DnsViewparamInfo(ctx _context.Context) ApiDnsViewparamInfoRequest {
	return ApiDnsViewparamInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewparamData
 */
func (a *DnsApiService) DnsViewparamInfoExecute(r ApiDnsViewparamInfoRequest) (DnsViewparamData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewparamInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/viewparam/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.viewId != nil {
		localVarQueryParams.Add("view_id", parameterToString(*r.viewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsViewparamListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
}

func (r ApiDnsViewparamListRequest) Orderby(orderby string) ApiDnsViewparamListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsViewparamListRequest) Where(where string) ApiDnsViewparamListRequest {
	r.where = &where
	return r
}
func (r ApiDnsViewparamListRequest) Limit(limit int32) ApiDnsViewparamListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsViewparamListRequest) Offset(offset int32) ApiDnsViewparamListRequest {
	r.offset = &offset
	return r
}

func (r ApiDnsViewparamListRequest) Execute() (DnsViewparamData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsViewparamListExecute(r)
}

/*
 * DnsViewparamList List the DNS options of a view
 * This service allows to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsViewparamListRequest
 */
func (a *DnsApiService) DnsViewparamList(ctx _context.Context) ApiDnsViewparamListRequest {
	return ApiDnsViewparamListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsViewparamData
 */
func (a *DnsApiService) DnsViewparamListExecute(r ApiDnsViewparamListRequest) (DnsViewparamData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsViewparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsViewparamList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/viewparam/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneAddRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsZoneAddInput *DnsZoneAddInput
}

func (r ApiDnsZoneAddRequest) DnsZoneAddInput(dnsZoneAddInput DnsZoneAddInput) ApiDnsZoneAddRequest {
	r.dnsZoneAddInput = &dnsZoneAddInput
	return r
}

func (r ApiDnsZoneAddRequest) Execute() (DnsZoneAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneAddExecute(r)
}

/*
 * DnsZoneAdd Add a zone
 * This service allows to add objects. A call can only add one object. To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_name && zone_type && (view_id || view_name) && (server_id || server_name || server_hostaddr))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneAddRequest
 */
func (a *DnsApiService) DnsZoneAdd(ctx _context.Context) ApiDnsZoneAddRequest {
	return ApiDnsZoneAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneAddSuccess
 */
func (a *DnsApiService) DnsZoneAddExecute(r ApiDnsZoneAddRequest) (DnsZoneAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneAdd")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zone/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
	tags *string
}

func (r ApiDnsZoneCountRequest) Where(where string) ApiDnsZoneCountRequest {
	r.where = &where
	return r
}
func (r ApiDnsZoneCountRequest) Tags(tags string) ApiDnsZoneCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsZoneCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneCountExecute(r)
}

/*
 * DnsZoneCount Count the number of zones
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneCountRequest
 */
func (a *DnsApiService) DnsZoneCount(ctx _context.Context) ApiDnsZoneCountRequest {
	return ApiDnsZoneCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsZoneCountExecute(r ApiDnsZoneCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zone/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneDeleteRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	serverId *int32
	serverName *string
	viewId *int32
	viewName *string
	zoneId *int32
	zoneName *string
	serverHostaddr *string
	warnings *string
}

func (r ApiDnsZoneDeleteRequest) ServerId(serverId int32) ApiDnsZoneDeleteRequest {
	r.serverId = &serverId
	return r
}
func (r ApiDnsZoneDeleteRequest) ServerName(serverName string) ApiDnsZoneDeleteRequest {
	r.serverName = &serverName
	return r
}
func (r ApiDnsZoneDeleteRequest) ViewId(viewId int32) ApiDnsZoneDeleteRequest {
	r.viewId = &viewId
	return r
}
func (r ApiDnsZoneDeleteRequest) ViewName(viewName string) ApiDnsZoneDeleteRequest {
	r.viewName = &viewName
	return r
}
func (r ApiDnsZoneDeleteRequest) ZoneId(zoneId int32) ApiDnsZoneDeleteRequest {
	r.zoneId = &zoneId
	return r
}
func (r ApiDnsZoneDeleteRequest) ZoneName(zoneName string) ApiDnsZoneDeleteRequest {
	r.zoneName = &zoneName
	return r
}
func (r ApiDnsZoneDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsZoneDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}
func (r ApiDnsZoneDeleteRequest) Warnings(warnings string) ApiDnsZoneDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsZoneDeleteRequest) Execute() (DnsZoneDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneDeleteExecute(r)
}

/*
 * DnsZoneDelete Delete a zone
 * This service allows to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id || (zone_name && (view_id || (view_name && (server_id || server_name || server_hostaddr)))))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneDeleteRequest
 */
func (a *DnsApiService) DnsZoneDelete(ctx _context.Context) ApiDnsZoneDeleteRequest {
	return ApiDnsZoneDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneDeleteSuccess
 */
func (a *DnsApiService) DnsZoneDeleteExecute(r ApiDnsZoneDeleteRequest) (DnsZoneDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneDelete")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zone/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.serverId != nil {
		localVarQueryParams.Add("server_id", parameterToString(*r.serverId, ""))
	}
	if r.serverName != nil {
		localVarQueryParams.Add("server_name", parameterToString(*r.serverName, ""))
	}
	if r.viewId != nil {
		localVarQueryParams.Add("view_id", parameterToString(*r.viewId, ""))
	}
	if r.viewName != nil {
		localVarQueryParams.Add("view_name", parameterToString(*r.viewName, ""))
	}
	if r.zoneId != nil {
		localVarQueryParams.Add("zone_id", parameterToString(*r.zoneId, ""))
	}
	if r.zoneName != nil {
		localVarQueryParams.Add("zone_name", parameterToString(*r.zoneName, ""))
	}
	if r.serverHostaddr != nil {
		localVarQueryParams.Add("server_hostaddr", parameterToString(*r.serverHostaddr, ""))
	}
	if r.warnings != nil {
		localVarQueryParams.Add("warnings", parameterToString(*r.warnings, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneEditRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsZoneEditInput *DnsZoneEditInput
}

func (r ApiDnsZoneEditRequest) DnsZoneEditInput(dnsZoneEditInput DnsZoneEditInput) ApiDnsZoneEditRequest {
	r.dnsZoneEditInput = &dnsZoneEditInput
	return r
}

func (r ApiDnsZoneEditRequest) Execute() (DnsZoneEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneEditExecute(r)
}

/*
 * DnsZoneEdit Edit a zone
 * This service allows to edit existing objects using their identifier. All the input parameters and their value specified in input edit the identified object, any parameter not specified is left unchanged. A call can only edit one object.  To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id || (zone_name && (view_id || view_name) && (server_id || server_name || server_hostaddr)))
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneEditRequest
 */
func (a *DnsApiService) DnsZoneEdit(ctx _context.Context) ApiDnsZoneEditRequest {
	return ApiDnsZoneEditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneEditSuccess
 */
func (a *DnsApiService) DnsZoneEditExecute(r ApiDnsZoneEditRequest) (DnsZoneEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneEdit")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zone/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	zoneId *int32
}

func (r ApiDnsZoneInfoRequest) ZoneId(zoneId int32) ApiDnsZoneInfoRequest {
	r.zoneId = &zoneId
	return r
}

func (r ApiDnsZoneInfoRequest) Execute() (DnsZoneData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneInfoExecute(r)
}

/*
 * DnsZoneInfo Display the properties of a zone
 * This service allows to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneInfoRequest
 */
func (a *DnsApiService) DnsZoneInfo(ctx _context.Context) ApiDnsZoneInfoRequest {
	return ApiDnsZoneInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneData
 */
func (a *DnsApiService) DnsZoneInfoExecute(r ApiDnsZoneInfoRequest) (DnsZoneData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zone/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.zoneId != nil {
		localVarQueryParams.Add("zone_id", parameterToString(*r.zoneId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
	tags *string
}

func (r ApiDnsZoneListRequest) Orderby(orderby string) ApiDnsZoneListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsZoneListRequest) Where(where string) ApiDnsZoneListRequest {
	r.where = &where
	return r
}
func (r ApiDnsZoneListRequest) Limit(limit int32) ApiDnsZoneListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsZoneListRequest) Offset(offset int32) ApiDnsZoneListRequest {
	r.offset = &offset
	return r
}
func (r ApiDnsZoneListRequest) Tags(tags string) ApiDnsZoneListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsZoneListRequest) Execute() (DnsZoneData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneListExecute(r)
}

/*
 * DnsZoneList List the DNS options of a zone
 * This service allows to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneListRequest
 */
func (a *DnsApiService) DnsZoneList(ctx _context.Context) ApiDnsZoneListRequest {
	return ApiDnsZoneListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneData
 */
func (a *DnsApiService) DnsZoneListExecute(r ApiDnsZoneListRequest) (DnsZoneData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zone/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneparamAddRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsZoneparamAddInput *DnsZoneparamAddInput
}

func (r ApiDnsZoneparamAddRequest) DnsZoneparamAddInput(dnsZoneparamAddInput DnsZoneparamAddInput) ApiDnsZoneparamAddRequest {
	r.dnsZoneparamAddInput = &dnsZoneparamAddInput
	return r
}

func (r ApiDnsZoneparamAddRequest) Execute() (DnsZoneparamAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneparamAddExecute(r)
}

/*
 * DnsZoneparamAdd Add a DNS option on a zone
 * This service allows to add objects. A call can only add one object. To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id && zoneparam_key)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneparamAddRequest
 */
func (a *DnsApiService) DnsZoneparamAdd(ctx _context.Context) ApiDnsZoneparamAddRequest {
	return ApiDnsZoneparamAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneparamAddSuccess
 */
func (a *DnsApiService) DnsZoneparamAddExecute(r ApiDnsZoneparamAddRequest) (DnsZoneparamAddSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneparamAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneparamAdd")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zoneparam/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneparamAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneparamAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneparamCountRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	where *string
}

func (r ApiDnsZoneparamCountRequest) Where(where string) ApiDnsZoneparamCountRequest {
	r.where = &where
	return r
}

func (r ApiDnsZoneparamCountRequest) Execute() (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneparamCountExecute(r)
}

/*
 * DnsZoneparamCount Count the number of DNS options of a zone
 * This service allows to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneparamCountRequest
 */
func (a *DnsApiService) DnsZoneparamCount(ctx _context.Context) ApiDnsZoneparamCountRequest {
	return ApiDnsZoneparamCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiCountResponseSuccess
 */
func (a *DnsApiService) DnsZoneparamCountExecute(r ApiDnsZoneparamCountRequest) (ApiCountResponseSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneparamCount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zoneparam/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneparamDeleteRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	zoneId *int32
	zoneparamKey *string
}

func (r ApiDnsZoneparamDeleteRequest) ZoneId(zoneId int32) ApiDnsZoneparamDeleteRequest {
	r.zoneId = &zoneId
	return r
}
func (r ApiDnsZoneparamDeleteRequest) ZoneparamKey(zoneparamKey string) ApiDnsZoneparamDeleteRequest {
	r.zoneparamKey = &zoneparamKey
	return r
}

func (r ApiDnsZoneparamDeleteRequest) Execute() (DnsZoneparamDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneparamDeleteExecute(r)
}

/*
 * DnsZoneparamDelete Delete a DNS option from a zone
 * This service allows to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id && zoneparam_key)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneparamDeleteRequest
 */
func (a *DnsApiService) DnsZoneparamDelete(ctx _context.Context) ApiDnsZoneparamDeleteRequest {
	return ApiDnsZoneparamDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneparamDeleteSuccess
 */
func (a *DnsApiService) DnsZoneparamDeleteExecute(r ApiDnsZoneparamDeleteRequest) (DnsZoneparamDeleteSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneparamDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneparamDelete")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zoneparam/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.zoneId != nil {
		localVarQueryParams.Add("zone_id", parameterToString(*r.zoneId, ""))
	}
	if r.zoneparamKey != nil {
		localVarQueryParams.Add("zoneparam_key", parameterToString(*r.zoneparamKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneparamDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneparamEditRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	dnsZoneparamEditInput *DnsZoneparamEditInput
}

func (r ApiDnsZoneparamEditRequest) DnsZoneparamEditInput(dnsZoneparamEditInput DnsZoneparamEditInput) ApiDnsZoneparamEditRequest {
	r.dnsZoneparamEditInput = &dnsZoneparamEditInput
	return r
}

func (r ApiDnsZoneparamEditRequest) Execute() (DnsZoneparamEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneparamEditExecute(r)
}

/*
 * DnsZoneparamEdit Edit a DNS option on a zone
 * This service allows to edit existing objects using their identifier. All the input parameters and their value specified in input edit the identified object, any parameter not specified is left unchanged. A call can only edit one object.  To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id && zoneparam_key)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneparamEditRequest
 */
func (a *DnsApiService) DnsZoneparamEdit(ctx _context.Context) ApiDnsZoneparamEditRequest {
	return ApiDnsZoneparamEditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneparamEditSuccess
 */
func (a *DnsApiService) DnsZoneparamEditExecute(r ApiDnsZoneparamEditRequest) (DnsZoneparamEditSuccess, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneparamEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneparamEdit")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zoneparam/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneparamEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneparamEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneparamInfoRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	zoneId *int32
}

func (r ApiDnsZoneparamInfoRequest) ZoneId(zoneId int32) ApiDnsZoneparamInfoRequest {
	r.zoneId = &zoneId
	return r
}

func (r ApiDnsZoneparamInfoRequest) Execute() (DnsZoneparamData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneparamInfoExecute(r)
}

/*
 * DnsZoneparamInfo Display the properties of a DNS option set on a zone
 * This service allows to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneparamInfoRequest
 */
func (a *DnsApiService) DnsZoneparamInfo(ctx _context.Context) ApiDnsZoneparamInfoRequest {
	return ApiDnsZoneparamInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneparamData
 */
func (a *DnsApiService) DnsZoneparamInfoExecute(r ApiDnsZoneparamInfoRequest) (DnsZoneparamData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneparamInfo")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zoneparam/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.zoneId != nil {
		localVarQueryParams.Add("zone_id", parameterToString(*r.zoneId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDnsZoneparamListRequest struct {
	ctx _context.Context
	ApiService *DnsApiService
	orderby *string
	where *string
	limit *int32
	offset *int32
}

func (r ApiDnsZoneparamListRequest) Orderby(orderby string) ApiDnsZoneparamListRequest {
	r.orderby = &orderby
	return r
}
func (r ApiDnsZoneparamListRequest) Where(where string) ApiDnsZoneparamListRequest {
	r.where = &where
	return r
}
func (r ApiDnsZoneparamListRequest) Limit(limit int32) ApiDnsZoneparamListRequest {
	r.limit = &limit
	return r
}
func (r ApiDnsZoneparamListRequest) Offset(offset int32) ApiDnsZoneparamListRequest {
	r.offset = &offset
	return r
}

func (r ApiDnsZoneparamListRequest) Execute() (DnsZoneparamData, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DnsZoneparamListExecute(r)
}

/*
 * DnsZoneparamList List the DNS options of a zone
 * This service allows to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDnsZoneparamListRequest
 */
func (a *DnsApiService) DnsZoneparamList(ctx _context.Context) ApiDnsZoneparamListRequest {
	return ApiDnsZoneparamListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DnsZoneparamData
 */
func (a *DnsApiService) DnsZoneparamListExecute(r ApiDnsZoneparamListRequest) (DnsZoneparamData, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  DnsZoneparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsApiService.DnsZoneparamList")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/dns/zoneparam/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.where != nil {
		localVarQueryParams.Add("where", parameterToString(*r.where, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
