/*
SOLIDserver API

OpenAPI 3.0.2 API definition for SOLIDserver service from EfficientIP.<p>Copyright Â© 2000-2024 EfficientIP</p><p><em>All specifications and information regarding the products in this document are subject to change without notice and should not be construed as a commitment by EfficientIP. EfficientIP assumes no responsibility or liability for any mistakes or inaccuracies that may appear in this document. All statements and recommendations in this document are believed to be accurate but are presented without warranty. Users must take full responsibility for their application of any product.</em></p><p><em>This document aims at detailing EfficientIP proprietary solutions. As our solutions rely on several third-party products, created by other companies or organizations, it may redirect readers to third-party websites and documentation for further information. In such a case, EfficientIP cannot be liable or expected to provide said information on products they do maintain or created.</em></p><p>Generated (Friday 4th of October 2024 03:41:11 PM)</p>

API version: 2.0
Contact: support-api@efficientip.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sdsclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// DnsAPIService DnsAPI service
type DnsAPIService service

type ApiDnsAclAddRequest struct {
	ctx            context.Context
	ApiService     *DnsAPIService
	dnsAclAddInput *DnsAclAddInput
}

func (r ApiDnsAclAddRequest) DnsAclAddInput(dnsAclAddInput DnsAclAddInput) ApiDnsAclAddRequest {
	r.dnsAclAddInput = &dnsAclAddInput
	return r
}

func (r ApiDnsAclAddRequest) Execute() (*DnsAclAddSuccess, *http.Response, error) {
	return r.ApiService.DnsAclAddExecute(r)
}

/*
DnsAclAdd Add a DNS ACL

This service allows you to add objects. A call can only add one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: ((acl_name && (server_id || server_name || server_hostaddr)) && acl_value)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsAclAddRequest
*/
func (a *DnsAPIService) DnsAclAdd(ctx context.Context) ApiDnsAclAddRequest {
	return ApiDnsAclAddRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsAclAddSuccess
func (a *DnsAPIService) DnsAclAddExecute(r ApiDnsAclAddRequest) (*DnsAclAddSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsAclAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsAclAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/acl/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsAclAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsAclAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsAclCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsAclCountRequest) Where(where string) ApiDnsAclCountRequest {
	r.where = &where
	return r
}

func (r ApiDnsAclCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsAclCountExecute(r)
}

/*
DnsAclCount Count the number of DNS ACLs

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsAclCountRequest
*/
func (a *DnsAPIService) DnsAclCount(ctx context.Context) ApiDnsAclCountRequest {
	return ApiDnsAclCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsAclCountExecute(r ApiDnsAclCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsAclCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/acl/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsAclDeleteRequest struct {
	ctx            context.Context
	ApiService     *DnsAPIService
	aclId          *int32
	serverId       *int32
	serverName     *string
	aclName        *string
	serverHostaddr *string
	warnings       *string
}

// The database identifier (ID) of the DNS ACL, a unique numeric key value automatically incremented when you add a DNS ACL. Use the ID to specify the DNS ACL of your choice.
func (r ApiDnsAclDeleteRequest) AclId(aclId int32) ApiDnsAclDeleteRequest {
	r.aclId = &aclId
	return r
}

// The database identifier (ID) of the DNS server, a unique numeric key value automatically incremented when you add a DNS server. Use the ID to specify the DNS server of your choice.
func (r ApiDnsAclDeleteRequest) ServerId(serverId int32) ApiDnsAclDeleteRequest {
	r.serverId = &serverId
	return r
}

// The name of the DNS server.
func (r ApiDnsAclDeleteRequest) ServerName(serverName string) ApiDnsAclDeleteRequest {
	r.serverName = &serverName
	return r
}

// The name of the DNS ACL.
func (r ApiDnsAclDeleteRequest) AclName(aclName string) ApiDnsAclDeleteRequest {
	r.aclName = &aclName
	return r
}

// The IP address of the DNS server.
func (r ApiDnsAclDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsAclDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}

// A way to bypass &lt;b&gt;(accept) &lt;/b&gt;any enabled rule that would return warning messages. If the service returns an error message, you cannot bypass the enabled rules.
func (r ApiDnsAclDeleteRequest) Warnings(warnings string) ApiDnsAclDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsAclDeleteRequest) Execute() (*DnsAclDeleteSuccess, *http.Response, error) {
	return r.ApiService.DnsAclDeleteExecute(r)
}

/*
DnsAclDelete Delete a DNS ACL

This service allows you to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: acl_id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsAclDeleteRequest
*/
func (a *DnsAPIService) DnsAclDelete(ctx context.Context) ApiDnsAclDeleteRequest {
	return ApiDnsAclDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsAclDeleteSuccess
func (a *DnsAPIService) DnsAclDeleteExecute(r ApiDnsAclDeleteRequest) (*DnsAclDeleteSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsAclDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsAclDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/acl/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aclId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acl_id", r.aclId, "form", "")
	}
	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_id", r.serverId, "form", "")
	}
	if r.serverName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_name", r.serverName, "form", "")
	}
	if r.aclName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acl_name", r.aclName, "form", "")
	}
	if r.serverHostaddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_hostaddr", r.serverHostaddr, "form", "")
	}
	if r.warnings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warnings", r.warnings, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsAclDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsAclEditRequest struct {
	ctx             context.Context
	ApiService      *DnsAPIService
	dnsAclEditInput *DnsAclEditInput
}

func (r ApiDnsAclEditRequest) DnsAclEditInput(dnsAclEditInput DnsAclEditInput) ApiDnsAclEditRequest {
	r.dnsAclEditInput = &dnsAclEditInput
	return r
}

func (r ApiDnsAclEditRequest) Execute() (*DnsAclEditSuccess, *http.Response, error) {
	return r.ApiService.DnsAclEditExecute(r)
}

/*
DnsAclEdit Edit a DNS ACL

This service allows you to edit existing ones. A call can only edit one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: ((acl_id || (acl_name && (server_id || server_name || server_hostaddr))) && acl_value)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsAclEditRequest
*/
func (a *DnsAPIService) DnsAclEdit(ctx context.Context) ApiDnsAclEditRequest {
	return ApiDnsAclEditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsAclEditSuccess
func (a *DnsAPIService) DnsAclEditExecute(r ApiDnsAclEditRequest) (*DnsAclEditSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsAclEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsAclEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/acl/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsAclEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsAclEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsAclInfoRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	aclId      *int32
}

// The database identifier (ID) of the DNS ACL, a unique numeric key value automatically incremented when you add a DNS ACL. Use the ID to specify the DNS ACL of your choice.
func (r ApiDnsAclInfoRequest) AclId(aclId int32) ApiDnsAclInfoRequest {
	r.aclId = &aclId
	return r
}

func (r ApiDnsAclInfoRequest) Execute() (*DnsAclData, *http.Response, error) {
	return r.ApiService.DnsAclInfoExecute(r)
}

/*
DnsAclInfo Display the properties of a DNS ACL

This service allows you to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsAclInfoRequest
*/
func (a *DnsAPIService) DnsAclInfo(ctx context.Context) ApiDnsAclInfoRequest {
	return ApiDnsAclInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsAclData
func (a *DnsAPIService) DnsAclInfoExecute(r ApiDnsAclInfoRequest) (*DnsAclData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsAclData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsAclInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/acl/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aclId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acl_id", r.aclId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsAclListRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	orderby    *string
	select_    *string
	where      *string
	limit      *int32
	offset     *int32
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsAclListRequest) Orderby(orderby string) ApiDnsAclListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsAclListRequest) Select_(select_ string) ApiDnsAclListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsAclListRequest) Where(where string) ApiDnsAclListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsAclListRequest) Limit(limit int32) ApiDnsAclListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsAclListRequest) Offset(offset int32) ApiDnsAclListRequest {
	r.offset = &offset
	return r
}

func (r ApiDnsAclListRequest) Execute() (*DnsAclData, *http.Response, error) {
	return r.ApiService.DnsAclListExecute(r)
}

/*
DnsAclList List the DNS ACLs

This service allows you to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsAclListRequest
*/
func (a *DnsAPIService) DnsAclList(ctx context.Context) ApiDnsAclListRequest {
	return ApiDnsAclListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsAclData
func (a *DnsAPIService) DnsAclListExecute(r ApiDnsAclListRequest) (*DnsAclData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsAclData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsAclList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/acl/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsRrAddRequest struct {
	ctx           context.Context
	ApiService    *DnsAPIService
	dnsRrAddInput *DnsRrAddInput
}

func (r ApiDnsRrAddRequest) DnsRrAddInput(dnsRrAddInput DnsRrAddInput) ApiDnsRrAddRequest {
	r.dnsRrAddInput = &dnsRrAddInput
	return r
}

func (r ApiDnsRrAddRequest) Execute() (*DnsRrAddSuccess, *http.Response, error) {
	return r.ApiService.DnsRrAddExecute(r)
}

/*
DnsRrAdd Add a resource record

This service allows you to add a resource record or edit an existing one.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.<br/>Adding some resource records requires to specify one or more values:<table><caption>Expected values for the DNS records</caption><br/><thead><tr><th>Type</th><th>Valuenumber</th><th>Related field(s)</th><th>Description</th></tr><br/></thead><br/><tbody><tr><td rowspan='7'>SOA</td><td >1</td><td >Name server</td><td >The FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.</td></tr><tr><td >2</td><td >Responsible</td><td >The administrator email address for the zone the record belongs to.</td></tr><tr><td >3</td><td >Serial number</td><td >The serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.</td></tr><tr><td >4</td><td >Refresh</td><td >The refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.</td></tr><tr><td >5</td><td >Retry</td><td >The retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.</td></tr><tr><td >6</td><td >Expiration</td><td >The expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.</td></tr><tr><td >7</td><td >Minimum</td><td >The minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.</td></tr><tr><td >NS</td><td >1</td><td >DNS server</td><td >The DNS server hostname.</td></tr><tr><td rowspan='2'>MX</td><td >1</td><td >Preference</td><td >A number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Mail server</td><td >The SMTP (mail) server hostname.</td></tr><tr><td >A</td><td >1</td><td >IP address</td><td >The IPv4 Address of the host.</td></tr><tr><td >AAAA</td><td >1</td><td >IPv6 address</td><td >The IPv6 Address of the host.</td></tr><tr><td >PTR</td><td >1</td><td >Localization</td><td >The hostname that should be returned when the IP address is queried.</td></tr><tr><td >CNAME</td><td >1</td><td >Hostname</td><td >The hostname.</td></tr><tr><td >TXT</td><td >1</td><td >Text</td><td >The description of your choice (max. 255 characters including spaces).</td></tr><tr><td rowspan='4'>SRV</td><td >1</td><td >Priority</td><td >A number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Weight</td><td >A number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in , there is no weighting.</td></tr><tr><td >3</td><td >Ports</td><td >The port number that delivers the service to the target.</td></tr><tr><td >4</td><td >Target</td><td >The hostname of the server delivering the service.</td></tr><tr><td rowspan='2'>HINFO</td><td >1</td><td >CPU</td><td >The name of the CPU, either , , , , , , , or .</td></tr><tr><td >2</td><td >OS</td><td >The name of the operating system, either , , , , , , , , , , , or .</td></tr><tr><td rowspan='2'>MINFO</td><td >1</td><td >Responsibleemail</td><td >The email address of the administrator of the mail list.</td></tr><tr><td >2</td><td >Error email</td><td >The email address that should receive the error messages regarding the mail list.</td></tr><tr><td >DNAME</td><td >1</td><td >Domain</td><td >The domain name of a subdomain of the zone.</td></tr><tr><td rowspan='2'>AFSDB</td><td >1</td><td >Preference</td><td >Type the version of AFS service used: (AFS version 3.0) or (OSF DCE/NCA version).</td></tr><tr><td >2</td><td >AFS server</td><td >The AFS hostname.</td></tr><tr><td rowspan='7'>NAPTR</td><td >1</td><td >Order</td><td >A number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Preference</td><td >A number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Flags</td><td >The string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field , and/or .</td></tr><tr><td >3</td><td >Services</td><td >The services parameters to which applies the action specified in the field . You must respect your client application syntax.</td></tr><tr><td >4</td><td >Regex</td><td >The string that contains a substitution expression matching the format to which applies the action specified the field .</td></tr><tr><td >5</td><td >Replace</td><td >An FQDN domain name to which applies the action specified the field . You can specify no domain name if you type in (dot) in the field.</td></tr><tr><td >For more details, refer to available on IETF website at .</td></tr><tr><td >NSAP</td><td >1</td><td >Name</td><td >The NSAP address of the end system. It should start with and not exceed 255 hexadecimal characters separated by dots.</td></tr><tr><td rowspan='4'>DS</td><td >1</td><td >Key Tag</td><td >The parent zone DS key tag.</td></tr><tr><td >2</td><td >Key Algorithm</td><td >The parent zone DS algorithm key.</td></tr><tr><td >3</td><td >Digest Type</td><td >The parent zone DS digest type.</td></tr><tr><td >4</td><td >Digest</td><td >The parent zone DS digest.</td></tr><tr><td rowspan='4'>DNSKEY</td><td >1</td><td >Flags</td><td >The zone key flag.</td></tr><tr><td >2</td><td >Protocol</td><td >The protocol value.</td></tr><tr><td >3</td><td >Algorithm</td><td >The public key's cryptographic algorithm.</td></tr><tr><td >4</td><td >Key</td><td >The public key material.</td></tr><tr><td rowspan='3'>WKS</td><td >1</td><td >IP address</td><td >The IPv4 Address of the host that contains the services listed in the Services field.</td></tr><tr><td >2</td><td >Protocol</td><td >The communication protocol, either or .</td></tr><tr><td >3</td><td >Services</td><td >The list of needed services.</td></tr></tbody></table></p><br/></br></br><b>Mandatory Parameters</b>: (rr_name && rr_type && rr_value1 && (server_id || server_name || server_hostaddr))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsRrAddRequest
*/
func (a *DnsAPIService) DnsRrAdd(ctx context.Context) ApiDnsRrAddRequest {
	return ApiDnsRrAddRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsRrAddSuccess
func (a *DnsAPIService) DnsRrAddExecute(r ApiDnsRrAddRequest) (*DnsRrAddSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsRrAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsRrAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/rr/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsRrAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsRrAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsRrCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
	tags       *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsRrCountRequest) Where(where string) ApiDnsRrCountRequest {
	r.where = &where
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsRrCountRequest) Tags(tags string) ApiDnsRrCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsRrCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsRrCountExecute(r)
}

/*
DnsRrCount Count the number of resource records

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsRrCountRequest
*/
func (a *DnsAPIService) DnsRrCount(ctx context.Context) ApiDnsRrCountRequest {
	return ApiDnsRrCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsRrCountExecute(r ApiDnsRrCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsRrCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/rr/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsRrDeleteRequest struct {
	ctx            context.Context
	ApiService     *DnsAPIService
	serverId       *int32
	serverName     *string
	serverHostaddr *string
	rrId           *int32
	rrName         *string
	viewId         *int32
	viewName       *string
	zoneId         *int32
	zoneName       *string
	zoneSpaceId    *int32
	rrType         *string
	rrValue1       *string
	rrValue2       *string
	rrValue3       *string
	rrValue4       *string
	rrValue5       *string
	rrValue6       *string
	rrValue7       *string
	warnings       *string
}

// The database identifier (ID) of the DNS server, a unique numeric key value automatically incremented when you add a DNS server. Use the ID to specify the DNS server of your choice.
func (r ApiDnsRrDeleteRequest) ServerId(serverId int32) ApiDnsRrDeleteRequest {
	r.serverId = &serverId
	return r
}

// The name of the DNS server.
func (r ApiDnsRrDeleteRequest) ServerName(serverName string) ApiDnsRrDeleteRequest {
	r.serverName = &serverName
	return r
}

// The IP address of the DNS server.
func (r ApiDnsRrDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsRrDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}

// The database identifier (ID) of the DNS resource record, a unique numeric key value automatically incremented when you add a DNS RR. Use the ID to specify the DNS RR of your choice.
func (r ApiDnsRrDeleteRequest) RrId(rrId int32) ApiDnsRrDeleteRequest {
	r.rrId = &rrId
	return r
}

// The name of the DNS resource record.
func (r ApiDnsRrDeleteRequest) RrName(rrName string) ApiDnsRrDeleteRequest {
	r.rrName = &rrName
	return r
}

// The database identifier (ID) of the DNS view, a unique numeric key value automatically incremented when you add a DNS view. Use the ID to specify the DNS view of your choice.
func (r ApiDnsRrDeleteRequest) ViewId(viewId int32) ApiDnsRrDeleteRequest {
	r.viewId = &viewId
	return r
}

// The name of the DNS view.
func (r ApiDnsRrDeleteRequest) ViewName(viewName string) ApiDnsRrDeleteRequest {
	r.viewName = &viewName
	return r
}

// The database identifier (ID) of the DNS zone, a unique numeric key value automatically incremented when you add a DNS zone. Use the ID to specify the DNS zone of your choice.
func (r ApiDnsRrDeleteRequest) ZoneId(zoneId int32) ApiDnsRrDeleteRequest {
	r.zoneId = &zoneId
	return r
}

// The name of the DNS zone the object belongs to.
func (r ApiDnsRrDeleteRequest) ZoneName(zoneName string) ApiDnsRrDeleteRequest {
	r.zoneName = &zoneName
	return r
}

// The database identifier (ID) of the space associated with the DNS zone the record belongs to.
func (r ApiDnsRrDeleteRequest) ZoneSpaceId(zoneSpaceId int32) ApiDnsRrDeleteRequest {
	r.zoneSpaceId = &zoneSpaceId
	return r
}

// The type of the DNS resource record.&lt;table&gt;&lt;caption&gt;rr_type possible values&lt;/caption&gt;&lt;br/&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Record type description&lt;/th&gt;&lt;/tr&gt;&lt;br/&gt;&lt;/thead&gt;&lt;br/&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td &gt;SOA&lt;/td&gt;&lt;td &gt;Start of Authority. Defines the zone name, an email contact and various time and refresh values applicable to the zone. It is automatically generated upon creation of a zone and cannot be added manually.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;NS&lt;/td&gt;&lt;td &gt;Name Server. Defines the authoritative name server(s) for the domain (defined by the SOA record) or the subdomain. The NS record that indicates which server has authority over a zone is automatically generated upon the creation of a zone, once the server has been synchronized.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;A&lt;/td&gt;&lt;td &gt;IPv4 Address. An IPv4 address for a host.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;PTR&lt;/td&gt;&lt;td &gt;Pointer Record. Address Resolution, from an IP address (IPv4 or IPv6) to a host. Used in reverse mapping.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;AAAA&lt;/td&gt;&lt;td &gt;IPv6 Address. An IPv6 address for a host.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;CNAME&lt;/td&gt;&lt;td &gt;Canonical Name. An alias name for a host.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;MX&lt;/td&gt;&lt;td &gt;Mail Exchange. The mail server/exchanger that services this zone.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;SRV&lt;/td&gt;&lt;td &gt;Services record. Defines services available in the zone, for example, LDAP, HTTP, etc...&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;DNAME&lt;/td&gt;&lt;td &gt;Delegation of Reverse Names. Delegation of reverse addresses primarily in IPv6. (Deprecated, use the CNAME RR instead)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;TXT&lt;/td&gt;&lt;td &gt;Text. Information associated with a name.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;DS&lt;/td&gt;&lt;td &gt;Delegation Signer, a DNSSEC related RR used to verify the validity of the ZSK of a subdomain.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;DNSKEY&lt;/td&gt;&lt;td &gt;DNS Key. It contains the public cryptographic key used to sign the zone with DNSSEC.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;65534&lt;/td&gt;&lt;td &gt;A private type record automatically added to the zone once it is signed with DNSSEC.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;HINFO&lt;/td&gt;&lt;td &gt;System Information. Information about a host: hardware type and operating system description.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;MINFO&lt;/td&gt;&lt;td &gt;Mailbox mail list Information. Defines the mail administrator for a mail list and optionally a mailbox to receive error messages relating to the mail list.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;AFSDB&lt;/td&gt;&lt;td &gt;AFS Database. Location of the AFS servers.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;WKS&lt;/td&gt;&lt;td &gt;Well-Known Service. Defines the services and protocols supported by a host. (Deprecated, use the SRV RR instead)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;NAPTR&lt;/td&gt;&lt;td &gt;Naming Authority Pointer Record. General purpose definition of rule set to be used by applications e.g. VoIP.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td &gt;NSAP&lt;/td&gt;&lt;td &gt;Network Service Access Point. Defines record (equivalent of an A record) maps a host name to an endpoint address.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;&lt;br/&gt;Note that the parameter is not case sensitive, you could type in &lt;b&gt;A&lt;/b&gt; or &lt;b&gt;a&lt;/b&gt;.
func (r ApiDnsRrDeleteRequest) RrType(rrType string) ApiDnsRrDeleteRequest {
	r.rrType = &rrType
	return r
}

// The first or only value required for the DNS resource record, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue1(rrValue1 string) ApiDnsRrDeleteRequest {
	r.rrValue1 = &rrValue1
	return r
}

// The second value of the DNS resource record, depending on its type, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue2(rrValue2 string) ApiDnsRrDeleteRequest {
	r.rrValue2 = &rrValue2
	return r
}

// The third value of the DNS resource record, depending on its type, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue3(rrValue3 string) ApiDnsRrDeleteRequest {
	r.rrValue3 = &rrValue3
	return r
}

// The fourth value of the DNS resource record, depending on its type, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue4(rrValue4 string) ApiDnsRrDeleteRequest {
	r.rrValue4 = &rrValue4
	return r
}

// The fifth value of the DNS resource record, depending on its type, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue5(rrValue5 string) ApiDnsRrDeleteRequest {
	r.rrValue5 = &rrValue5
	return r
}

// The sixth value of the DNS resource record, depending on its type, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue6(rrValue6 string) ApiDnsRrDeleteRequest {
	r.rrValue6 = &rrValue6
	return r
}

// The seventh value of the DNS resource record, depending on its type, as detailed in the service description
func (r ApiDnsRrDeleteRequest) RrValue7(rrValue7 string) ApiDnsRrDeleteRequest {
	r.rrValue7 = &rrValue7
	return r
}

// A way to bypass &lt;b&gt;(accept) &lt;/b&gt;any enabled rule that would return warning messages. If the service returns an error message, you cannot bypass the enabled rules.
func (r ApiDnsRrDeleteRequest) Warnings(warnings string) ApiDnsRrDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsRrDeleteRequest) Execute() (*DnsRrDeleteSuccess, *http.Response, error) {
	return r.ApiService.DnsRrDeleteExecute(r)
}

/*
DnsRrDelete Delete a resource record

This service allows you to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (rr_id || (rr_name && (server_id || server_name || server_hostaddr)))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsRrDeleteRequest
*/
func (a *DnsAPIService) DnsRrDelete(ctx context.Context) ApiDnsRrDeleteRequest {
	return ApiDnsRrDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsRrDeleteSuccess
func (a *DnsAPIService) DnsRrDeleteExecute(r ApiDnsRrDeleteRequest) (*DnsRrDeleteSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsRrDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsRrDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/rr/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_id", r.serverId, "form", "")
	}
	if r.serverName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_name", r.serverName, "form", "")
	}
	if r.serverHostaddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_hostaddr", r.serverHostaddr, "form", "")
	}
	if r.rrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_id", r.rrId, "form", "")
	}
	if r.rrName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_name", r.rrName, "form", "")
	}
	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "form", "")
	}
	if r.viewName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_name", r.viewName, "form", "")
	}
	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_id", r.zoneId, "form", "")
	}
	if r.zoneName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_name", r.zoneName, "form", "")
	}
	if r.zoneSpaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_space_id", r.zoneSpaceId, "form", "")
	}
	if r.rrType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_type", r.rrType, "form", "")
	}
	if r.rrValue1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value1", r.rrValue1, "form", "")
	}
	if r.rrValue2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value2", r.rrValue2, "form", "")
	}
	if r.rrValue3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value3", r.rrValue3, "form", "")
	}
	if r.rrValue4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value4", r.rrValue4, "form", "")
	}
	if r.rrValue5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value5", r.rrValue5, "form", "")
	}
	if r.rrValue6 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value6", r.rrValue6, "form", "")
	}
	if r.rrValue7 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_value7", r.rrValue7, "form", "")
	}
	if r.warnings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warnings", r.warnings, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsRrDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsRrEditRequest struct {
	ctx            context.Context
	ApiService     *DnsAPIService
	dnsRrEditInput *DnsRrEditInput
}

func (r ApiDnsRrEditRequest) DnsRrEditInput(dnsRrEditInput DnsRrEditInput) ApiDnsRrEditRequest {
	r.dnsRrEditInput = &dnsRrEditInput
	return r
}

func (r ApiDnsRrEditRequest) Execute() (*DnsRrEditSuccess, *http.Response, error) {
	return r.ApiService.DnsRrEditExecute(r)
}

/*
DnsRrEdit Edit a resource record

This service allows you to add a resource record or edit an existing one.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.<br/>Adding some resource records requires to specify one or more values:<table><caption>Expected values for the DNS records</caption><br/><thead><tr><th>Type</th><th>Valuenumber</th><th>Related field(s)</th><th>Description</th></tr><br/></thead><br/><tbody><tr><td rowspan='7'>SOA</td><td >1</td><td >Name server</td><td >The FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.</td></tr><tr><td >2</td><td >Responsible</td><td >The administrator email address for the zone the record belongs to.</td></tr><tr><td >3</td><td >Serial number</td><td >The serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.</td></tr><tr><td >4</td><td >Refresh</td><td >The refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.</td></tr><tr><td >5</td><td >Retry</td><td >The retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.</td></tr><tr><td >6</td><td >Expiration</td><td >The expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.</td></tr><tr><td >7</td><td >Minimum</td><td >The minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.</td></tr><tr><td >NS</td><td >1</td><td >DNS server</td><td >The DNS server hostname.</td></tr><tr><td rowspan='2'>MX</td><td >1</td><td >Preference</td><td >A number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Mail server</td><td >The SMTP (mail) server hostname.</td></tr><tr><td >A</td><td >1</td><td >IP address</td><td >The IPv4 Address of the host.</td></tr><tr><td >AAAA</td><td >1</td><td >IPv6 address</td><td >The IPv6 Address of the host.</td></tr><tr><td >PTR</td><td >1</td><td >Localization</td><td >The hostname that should be returned when the IP address is queried.</td></tr><tr><td >CNAME</td><td >1</td><td >Hostname</td><td >The hostname.</td></tr><tr><td >TXT</td><td >1</td><td >Text</td><td >The description of your choice (max. 255 characters including spaces).</td></tr><tr><td rowspan='4'>SRV</td><td >1</td><td >Priority</td><td >A number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Weight</td><td >A number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in , there is no weighting.</td></tr><tr><td >3</td><td >Ports</td><td >The port number that delivers the service to the target.</td></tr><tr><td >4</td><td >Target</td><td >The hostname of the server delivering the service.</td></tr><tr><td rowspan='2'>HINFO</td><td >1</td><td >CPU</td><td >The name of the CPU, either , , , , , , , or .</td></tr><tr><td >2</td><td >OS</td><td >The name of the operating system, either , , , , , , , , , , , or .</td></tr><tr><td rowspan='2'>MINFO</td><td >1</td><td >Responsibleemail</td><td >The email address of the administrator of the mail list.</td></tr><tr><td >2</td><td >Error email</td><td >The email address that should receive the error messages regarding the mail list.</td></tr><tr><td >DNAME</td><td >1</td><td >Domain</td><td >The domain name of a subdomain of the zone.</td></tr><tr><td rowspan='2'>AFSDB</td><td >1</td><td >Preference</td><td >Type the version of AFS service used: (AFS version 3.0) or (OSF DCE/NCA version).</td></tr><tr><td >2</td><td >AFS server</td><td >The AFS hostname.</td></tr><tr><td rowspan='7'>NAPTR</td><td >1</td><td >Order</td><td >A number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Preference</td><td >A number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Flags</td><td >The string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field , and/or .</td></tr><tr><td >3</td><td >Services</td><td >The services parameters to which applies the action specified in the field . You must respect your client application syntax.</td></tr><tr><td >4</td><td >Regex</td><td >The string that contains a substitution expression matching the format to which applies the action specified the field .</td></tr><tr><td >5</td><td >Replace</td><td >An FQDN domain name to which applies the action specified the field . You can specify no domain name if you type in (dot) in the field.</td></tr><tr><td >For more details, refer to available on IETF website at .</td></tr><tr><td >NSAP</td><td >1</td><td >Name</td><td >The NSAP address of the end system. It should start with and not exceed 255 hexadecimal characters separated by dots.</td></tr><tr><td rowspan='4'>DS</td><td >1</td><td >Key Tag</td><td >The parent zone DS key tag.</td></tr><tr><td >2</td><td >Key Algorithm</td><td >The parent zone DS algorithm key.</td></tr><tr><td >3</td><td >Digest Type</td><td >The parent zone DS digest type.</td></tr><tr><td >4</td><td >Digest</td><td >The parent zone DS digest.</td></tr><tr><td rowspan='4'>DNSKEY</td><td >1</td><td >Flags</td><td >The zone key flag.</td></tr><tr><td >2</td><td >Protocol</td><td >The protocol value.</td></tr><tr><td >3</td><td >Algorithm</td><td >The public key's cryptographic algorithm.</td></tr><tr><td >4</td><td >Key</td><td >The public key material.</td></tr><tr><td rowspan='3'>WKS</td><td >1</td><td >IP address</td><td >The IPv4 Address of the host that contains the services listed in the Services field.</td></tr><tr><td >2</td><td >Protocol</td><td >The communication protocol, either or .</td></tr><tr><td >3</td><td >Services</td><td >The list of needed services.</td></tr></tbody></table></p><br/></br></br><b>Mandatory Parameters</b>: (rr_id || (rr_name && rr_type && rr_value1 && (server_id || server_name || server_hostaddr)))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsRrEditRequest
*/
func (a *DnsAPIService) DnsRrEdit(ctx context.Context) ApiDnsRrEditRequest {
	return ApiDnsRrEditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsRrEditSuccess
func (a *DnsAPIService) DnsRrEditExecute(r ApiDnsRrEditRequest) (*DnsRrEditSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsRrEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsRrEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/rr/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsRrEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsRrEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsRrInfoRequest struct {
	ctx                context.Context
	ApiService         *DnsAPIService
	noParentClassParam *int32
	rrId               *int32
}

// A way to exclude the class parameter details of the parent of the object in the output parameter dedicated to its class parameters.
func (r ApiDnsRrInfoRequest) NoParentClassParam(noParentClassParam int32) ApiDnsRrInfoRequest {
	r.noParentClassParam = &noParentClassParam
	return r
}

// The database identifier (ID) of the DNS resource record, a unique numeric key value automatically incremented when you add a DNS RR. Use the ID to specify the DNS RR of your choice.
func (r ApiDnsRrInfoRequest) RrId(rrId int32) ApiDnsRrInfoRequest {
	r.rrId = &rrId
	return r
}

func (r ApiDnsRrInfoRequest) Execute() (*DnsRrData, *http.Response, error) {
	return r.ApiService.DnsRrInfoExecute(r)
}

/*
DnsRrInfo Display the properties of a resource record

This service allows to display the properties of a resource record.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.Adding some resource records requires to specify one or more values:<br/>                                Expected values for the DNS records<br/>                                <br/>                                    <br/>                                    <br/>                                    <br/>                                    <br/>                                    <br/>                                        <br/>                                            Type<br/>                                            Value number<br/>                                            Related field(s)<br/>                                            Syntax<br/>                                        <br/>                                    <br/>                                    <br/>                                        <br/>                                            SOA<br/>                                            1<br/>                                            Name server<br/>                                            Type in the FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Responsible<br/>                                            Type in the administrator email address for the zone the record belongs to.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Serial number<br/>                                            Type in the serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Refresh<br/>                                            Type in the refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.<br/>                                        <br/>                                        <br/>                                            5<br/>                                            Retry<br/>                                            Type in the retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.<br/>                                        <br/>                                        <br/>                                            6<br/>                                            Expiration<br/>                                            Type in the expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.<br/>                                        <br/>                                        <br/>                                            7<br/>                                            Minimum<br/>                                            Type in the minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.<br/>                                        <br/>                                        <br/>                                            NS<br/>                                            1<br/>                                            DNS server<br/>                                            Type in the DNS server hostname.<br/>                                        <br/>                                        <br/>                                            MX<br/>                                            1<br/>                                            Preference<br/>                                            Type a number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Mail server<br/>                                            Type in the SMTP (mail) server hostname.<br/>                                        <br/>                                        <br/>                                            A<br/>                                            1<br/>                                            IP address<br/>                                            Type in the IPv4 Address of the host.<br/>                                        <br/>                                        <br/>                                            AAAA<br/>                                            1<br/>                                            IPv6 address<br/>                                            Type in the IPv6 Address of the host.<br/>                                        <br/>                                        <br/>                                            PTR<br/>                                            1<br/>                                            Localization<br/>                                            Type in the hostname that should be returned when the IP address is queried.<br/>                                        <br/>                                        <br/>                                            CNAME<br/>                                            1<br/>                                            Hostname<br/>                                            Type in the hostname.<br/>                                        <br/>                                        <br/>                                            TXT<br/>                                            1<br/>                                            Text<br/>                                            Type in the description of your choice (max. 255 characters including spaces).<br/>                                        <br/>                                        <br/>                                            SRV<br/>                                            1<br/>                                            Priority<br/>                                            Type a number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Weight<br/>                                            Type a number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in 0, there is no weighting.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Ports<br/>                                            Type in the port number that delivers the service to the target.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Target<br/>                                            Type in the hostname of the server delivering the service.<br/>                                        <br/>                                        <br/>                                            HINFO<br/>                                            1<br/>                                            CPU<br/>                                            Type in the name of the CPU, either INTEL, AMD, SPARC, ALPHA, HPPA, POWERPC, MIPS, MOTOROLA or Other.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            OS<br/>                                            The name of the operating system, either AIX, FREEBSD, HPUX, IRIX, LINUX, OSF, OS/2, SOLARIS, SUNOS, VMS, WINDOWS, or Other.<br/>                                        <br/>                                        <br/>                                            MINFO<br/>                                            1<br/>                                            Responsible email<br/>                                            Type in the email address of the administrator of the mail list.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Error email<br/>                                            Type in the email address that should receive the error messages regarding the mail list.<br/>                                        <br/>                                        <br/>                                            DNAME<br/>                                            1<br/>                                            Domain<br/>                                            Type in the domain name of a subdomain of the zone.<br/>                                        <br/>                                        <br/>                                            AFSDB<br/>                                            1<br/>                                            Preference<br/>                                            Type the version of AFS service used: 1 (AFS version 3.0) or 2 (OSF DCE/NCA version).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            AFS server<br/>                                            Type in the AFS hostname.<br/>                                        <br/>                                        <br/>                                            NAPTR<br/>                                                    The record NAPTR is described in the RFC 3403, available on IETF website: http://tools.ietf.org/html/rfc3403.<br/>                                                <br/>                                            1<br/>                                            Order<br/>                                            Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Preference<br/>                                            Type a number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Flags<br/>                                            Type in the string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field Services, Regex and/or Replace.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Services<br/>                                            Type in the services parameters to which applies the action specified in the field Flags. You must respect your client application syntax.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Regex<br/>                                            Type in the string that contains a substitution expression matching the format <delimit ereg delimit substitution delimit flag> to which applies the action specified the field Flags.<br/>                                        <br/>                                        <br/>                                            5<br/>                                            Replace<br/>                                            Type in an FQDN domain name to which applies the action specified the field Flags. You can specify no domain name if you type in . (dot) in the field.<br/>                                        <br/>                                        <br/>                                            NSAP<br/>                                            1<br/>                                            Name<br/>                                            Type in the NSAP address of the end system. It should start with 0x and not exceed 255 hexadecimal characters separated by dots.<br/>                                        <br/>                                        <br/>                                            DS<br/>                                            1<br/>                                            Key Tag<br/>                                            Type in the parent zone DS key tag.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Key Algorithm<br/>                                            Type in the parent zone DS algorithm key.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Digest Type<br/>                                            Type in the parent zone DS digest type.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Digest<br/>                                            Type in the parent zone DS digest.<br/>                                        <br/>                                        <br/>                                            DNSKEY<br/>                                            1<br/>                                            Flags<br/>                                            Type in or paste the zone key flag.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Protocol<br/>                                            Type in or paste the protocol value.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Algorithm<br/>                                            Type in or paste the public key's cryptographic algorithm.<br/>                                        <br/>                                        <br/>                                            4<br/>                                            Key<br/>                                            Type in or paste the public key material.<br/>                                        <br/>                                        <br/>                                            WKS<br/>                                            1<br/>                                            IP address<br/>                                            Type in the IPv4 Address of the host that contains the services listed in the Services field.<br/>                                        <br/>                                        <br/>                                            2<br/>                                            Protocol<br/>                                            Type in TCP or UDP.<br/>                                        <br/>                                        <br/>                                            3<br/>                                            Services<br/>                                            Type in the list of needed services.<br/>                                        <br/>                                    <br/>                                <br/>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsRrInfoRequest
*/
func (a *DnsAPIService) DnsRrInfo(ctx context.Context) ApiDnsRrInfoRequest {
	return ApiDnsRrInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsRrData
func (a *DnsAPIService) DnsRrInfoExecute(r ApiDnsRrInfoRequest) (*DnsRrData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsRrData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsRrInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/rr/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.noParentClassParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_parent_class_param", r.noParentClassParam, "form", "")
	}
	if r.rrId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rr_id", r.rrId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsRrListRequest struct {
	ctx                context.Context
	ApiService         *DnsAPIService
	orderby            *string
	select_            *string
	where              *string
	limit              *int32
	offset             *int32
	noParentClassParam *int32
	tags               *string
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsRrListRequest) Orderby(orderby string) ApiDnsRrListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsRrListRequest) Select_(select_ string) ApiDnsRrListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsRrListRequest) Where(where string) ApiDnsRrListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsRrListRequest) Limit(limit int32) ApiDnsRrListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsRrListRequest) Offset(offset int32) ApiDnsRrListRequest {
	r.offset = &offset
	return r
}

// A way to exclude the class parameter details of the parent of the object in the output parameter dedicated to its class parameters.
func (r ApiDnsRrListRequest) NoParentClassParam(noParentClassParam int32) ApiDnsRrListRequest {
	r.noParentClassParam = &noParentClassParam
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsRrListRequest) Tags(tags string) ApiDnsRrListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsRrListRequest) Execute() (*DnsRrData, *http.Response, error) {
	return r.ApiService.DnsRrListExecute(r)
}

/*
DnsRrList List the resource records

This service allows you to list the resource records.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.<br/>Adding some resource records requires to specify one or more values:<table><caption>Expected values for the DNS records</caption><br/><thead><tr><th>Type</th><th>Valuenumber</th><th>Related field(s)</th><th>Description</th></tr><br/></thead><br/><tbody><tr><td rowspan='7'>SOA</td><td >1</td><td >Name server</td><td >The FQDN of the primary Master name server for the zone the record belongs to. Has a special meaning when used with Dynamic DNS (DDNS): called MNAME, it allows the DNS client to know on which DNS server it has to update itself with DDNS.</td></tr><tr><td >2</td><td >Responsible</td><td >The administrator email address for the zone the record belongs to.</td></tr><tr><td >3</td><td >Serial number</td><td >The serial number for the zone the record belongs to. The serial number is automatically incremented for each zone change.</td></tr><tr><td >4</td><td >Refresh</td><td >The refresh delay for the zone the record belongs to, in seconds. When reached, it forces the slave name server(s) to read the SOA record. If this record is higher than the slave's one, a zone transfer will be triggered by the slave to get the latest version of the zone. Typical values are 3 to 24 hours.</td></tr><tr><td >5</td><td >Retry</td><td >The retry delay for the zone the record belongs to, in seconds. When reached, it forces the slave server to retry the request if it fails to reach the master server during a refresh cycle. Typical values are from 10 to 60 minutes.</td></tr><tr><td >6</td><td >Expiration</td><td >The expiration time for the zone the record belongs to, in seconds. When reached, the zone records are considered to be no longer valid/authoritative. The DNS server then stops responding to queries for the zone. To avoid a major outage, the typical value is pretty high, between 1 to 3 weeks.</td></tr><tr><td >7</td><td >Minimum</td><td >The minimum time for the zone the record belongs to, in seconds. It defines the period of time that negative responses can be cached from the slave. For instance, if a request cannot be resolved, the server will answer with a NXDOMAIN result (No such domain). The server will continue returning this value until the Minimum value expires, then it will retry the resolution. This value has to be between 0 and 3 hours.</td></tr><tr><td >NS</td><td >1</td><td >DNS server</td><td >The DNS server hostname.</td></tr><tr><td rowspan='2'>MX</td><td >1</td><td >Preference</td><td >A number, between 0 and 65535, to define which server has priority if there are several RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Mail server</td><td >The SMTP (mail) server hostname.</td></tr><tr><td >A</td><td >1</td><td >IP address</td><td >The IPv4 Address of the host.</td></tr><tr><td >AAAA</td><td >1</td><td >IPv6 address</td><td >The IPv6 Address of the host.</td></tr><tr><td >PTR</td><td >1</td><td >Localization</td><td >The hostname that should be returned when the IP address is queried.</td></tr><tr><td >CNAME</td><td >1</td><td >Hostname</td><td >The hostname.</td></tr><tr><td >TXT</td><td >1</td><td >Text</td><td >The description of your choice (max. 255 characters including spaces).</td></tr><tr><td rowspan='4'>SRV</td><td >1</td><td >Priority</td><td >A number, between 0 and 65535, to define which server has priority if there are several SRV RRs in the zone. The lowest the value has the priority over the other server(s).</td></tr><tr><td >2</td><td >Weight</td><td >A number, between 0 and 65535, that defines the server weight. If two SRV RRs have the same priority, the weight defines which server is more used. The field gives priority to the SRV RR with the greatest weight value: the greater the value is, the more the server is solicited. If you type in , there is no weighting.</td></tr><tr><td >3</td><td >Ports</td><td >The port number that delivers the service to the target.</td></tr><tr><td >4</td><td >Target</td><td >The hostname of the server delivering the service.</td></tr><tr><td rowspan='2'>HINFO</td><td >1</td><td >CPU</td><td >The name of the CPU, either , , , , , , , or .</td></tr><tr><td >2</td><td >OS</td><td >The name of the operating system, either , , , , , , , , , , , or .</td></tr><tr><td rowspan='2'>MINFO</td><td >1</td><td >Responsibleemail</td><td >The email address of the administrator of the mail list.</td></tr><tr><td >2</td><td >Error email</td><td >The email address that should receive the error messages regarding the mail list.</td></tr><tr><td >DNAME</td><td >1</td><td >Domain</td><td >The domain name of a subdomain of the zone.</td></tr><tr><td rowspan='2'>AFSDB</td><td >1</td><td >Preference</td><td >Type the version of AFS service used: (AFS version 3.0) or (OSF DCE/NCA version).</td></tr><tr><td >2</td><td >AFS server</td><td >The AFS hostname.</td></tr><tr><td rowspan='7'>NAPTR</td><td >1</td><td >Order</td><td >A number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Preference</td><td >A number, between 0 and 65535, to define which RR has priority if there are several NAPTR RRs have the same order in the zone. The lowest the value has the priority over the other record(s).</td></tr><tr><td >2</td><td >Flags</td><td >The string that corresponds to the action you want your client application to perform. The flag specified impacts the data expected in the field , and/or .</td></tr><tr><td >3</td><td >Services</td><td >The services parameters to which applies the action specified in the field . You must respect your client application syntax.</td></tr><tr><td >4</td><td >Regex</td><td >The string that contains a substitution expression matching the format to which applies the action specified the field .</td></tr><tr><td >5</td><td >Replace</td><td >An FQDN domain name to which applies the action specified the field . You can specify no domain name if you type in (dot) in the field.</td></tr><tr><td >For more details, refer to available on IETF website at .</td></tr><tr><td >NSAP</td><td >1</td><td >Name</td><td >The NSAP address of the end system. It should start with and not exceed 255 hexadecimal characters separated by dots.</td></tr><tr><td rowspan='4'>DS</td><td >1</td><td >Key Tag</td><td >The parent zone DS key tag.</td></tr><tr><td >2</td><td >Key Algorithm</td><td >The parent zone DS algorithm key.</td></tr><tr><td >3</td><td >Digest Type</td><td >The parent zone DS digest type.</td></tr><tr><td >4</td><td >Digest</td><td >The parent zone DS digest.</td></tr><tr><td rowspan='4'>DNSKEY</td><td >1</td><td >Flags</td><td >The zone key flag.</td></tr><tr><td >2</td><td >Protocol</td><td >The protocol value.</td></tr><tr><td >3</td><td >Algorithm</td><td >The public key's cryptographic algorithm.</td></tr><tr><td >4</td><td >Key</td><td >The public key material.</td></tr><tr><td rowspan='3'>WKS</td><td >1</td><td >IP address</td><td >The IPv4 Address of the host that contains the services listed in the Services field.</td></tr><tr><td >2</td><td >Protocol</td><td >The communication protocol, either or .</td></tr><tr><td >3</td><td >Services</td><td >The list of needed services.</td></tr></tbody></table></p><br/>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsRrListRequest
*/
func (a *DnsAPIService) DnsRrList(ctx context.Context) ApiDnsRrListRequest {
	return ApiDnsRrListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsRrData
func (a *DnsAPIService) DnsRrListExecute(r ApiDnsRrListRequest) (*DnsRrData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsRrData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsRrList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/rr/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.noParentClassParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_parent_class_param", r.noParentClassParam, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsServerCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
	tags       *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsServerCountRequest) Where(where string) ApiDnsServerCountRequest {
	r.where = &where
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsServerCountRequest) Tags(tags string) ApiDnsServerCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsServerCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsServerCountExecute(r)
}

/*
DnsServerCount Count the number of DNS servers

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsServerCountRequest
*/
func (a *DnsAPIService) DnsServerCount(ctx context.Context) ApiDnsServerCountRequest {
	return ApiDnsServerCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsServerCountExecute(r ApiDnsServerCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsServerCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/server/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsServerInfoRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	serverId   *int32
}

// The database identifier (ID) of the DNS server, a unique numeric key value automatically incremented when you add a DNS server. Use the ID to specify the DNS server of your choice.
func (r ApiDnsServerInfoRequest) ServerId(serverId int32) ApiDnsServerInfoRequest {
	r.serverId = &serverId
	return r
}

func (r ApiDnsServerInfoRequest) Execute() (*DnsServerData, *http.Response, error) {
	return r.ApiService.DnsServerInfoExecute(r)
}

/*
DnsServerInfo Display the properties of a DNS server

This service allows you to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsServerInfoRequest
*/
func (a *DnsAPIService) DnsServerInfo(ctx context.Context) ApiDnsServerInfoRequest {
	return ApiDnsServerInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsServerData
func (a *DnsAPIService) DnsServerInfoExecute(r ApiDnsServerInfoRequest) (*DnsServerData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsServerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsServerInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/server/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_id", r.serverId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsServerListRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	orderby    *string
	select_    *string
	where      *string
	limit      *int32
	offset     *int32
	tags       *string
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsServerListRequest) Orderby(orderby string) ApiDnsServerListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsServerListRequest) Select_(select_ string) ApiDnsServerListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsServerListRequest) Where(where string) ApiDnsServerListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsServerListRequest) Limit(limit int32) ApiDnsServerListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsServerListRequest) Offset(offset int32) ApiDnsServerListRequest {
	r.offset = &offset
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsServerListRequest) Tags(tags string) ApiDnsServerListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsServerListRequest) Execute() (*DnsServerData, *http.Response, error) {
	return r.ApiService.DnsServerListExecute(r)
}

/*
DnsServerList List the DNS servers

This service allows you to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsServerListRequest
*/
func (a *DnsAPIService) DnsServerList(ctx context.Context) ApiDnsServerListRequest {
	return ApiDnsServerListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsServerData
func (a *DnsAPIService) DnsServerListExecute(r ApiDnsServerListRequest) (*DnsServerData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsServerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsServerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/server/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewAddRequest struct {
	ctx             context.Context
	ApiService      *DnsAPIService
	dnsViewAddInput *DnsViewAddInput
}

func (r ApiDnsViewAddRequest) DnsViewAddInput(dnsViewAddInput DnsViewAddInput) ApiDnsViewAddRequest {
	r.dnsViewAddInput = &dnsViewAddInput
	return r
}

func (r ApiDnsViewAddRequest) Execute() (*DnsViewAddSuccess, *http.Response, error) {
	return r.ApiService.DnsViewAddExecute(r)
}

/*
DnsViewAdd Add a view

This service allows you to add objects. A call can only add one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_name && (server_id || server_name || server_hostaddr))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewAddRequest
*/
func (a *DnsAPIService) DnsViewAdd(ctx context.Context) ApiDnsViewAddRequest {
	return ApiDnsViewAddRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewAddSuccess
func (a *DnsAPIService) DnsViewAddExecute(r ApiDnsViewAddRequest) (*DnsViewAddSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/view/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
	tags       *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsViewCountRequest) Where(where string) ApiDnsViewCountRequest {
	r.where = &where
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsViewCountRequest) Tags(tags string) ApiDnsViewCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsViewCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsViewCountExecute(r)
}

/*
DnsViewCount Count the number of views

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewCountRequest
*/
func (a *DnsAPIService) DnsViewCount(ctx context.Context) ApiDnsViewCountRequest {
	return ApiDnsViewCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsViewCountExecute(r ApiDnsViewCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/view/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewDeleteRequest struct {
	ctx            context.Context
	ApiService     *DnsAPIService
	serverId       *int32
	serverName     *string
	viewId         *int32
	viewName       *string
	serverHostaddr *string
	warnings       *string
}

// The database identifier (ID) of the DNS server, a unique numeric key value automatically incremented when you add a DNS server. Use the ID to specify the DNS server of your choice.
func (r ApiDnsViewDeleteRequest) ServerId(serverId int32) ApiDnsViewDeleteRequest {
	r.serverId = &serverId
	return r
}

// The name of the DNS server.
func (r ApiDnsViewDeleteRequest) ServerName(serverName string) ApiDnsViewDeleteRequest {
	r.serverName = &serverName
	return r
}

// The database identifier (ID) of the DNS view. Use the ID to specify the DNS view of your choice.
func (r ApiDnsViewDeleteRequest) ViewId(viewId int32) ApiDnsViewDeleteRequest {
	r.viewId = &viewId
	return r
}

// The name of the DNS view.
func (r ApiDnsViewDeleteRequest) ViewName(viewName string) ApiDnsViewDeleteRequest {
	r.viewName = &viewName
	return r
}

// The IP address of the DNS server.
func (r ApiDnsViewDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsViewDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}

// A way to bypass &lt;b&gt;(accept) &lt;/b&gt;any enabled rule that would return warning messages. If the service returns an error message, you cannot bypass the enabled rules.
func (r ApiDnsViewDeleteRequest) Warnings(warnings string) ApiDnsViewDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsViewDeleteRequest) Execute() (*DnsViewDeleteSuccess, *http.Response, error) {
	return r.ApiService.DnsViewDeleteExecute(r)
}

/*
DnsViewDelete Delete a view

This service allows you to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id || (view_name && (server_id || server_name || server_hostaddr)))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewDeleteRequest
*/
func (a *DnsAPIService) DnsViewDelete(ctx context.Context) ApiDnsViewDeleteRequest {
	return ApiDnsViewDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewDeleteSuccess
func (a *DnsAPIService) DnsViewDeleteExecute(r ApiDnsViewDeleteRequest) (*DnsViewDeleteSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/view/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_id", r.serverId, "form", "")
	}
	if r.serverName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_name", r.serverName, "form", "")
	}
	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "form", "")
	}
	if r.viewName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_name", r.viewName, "form", "")
	}
	if r.serverHostaddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_hostaddr", r.serverHostaddr, "form", "")
	}
	if r.warnings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warnings", r.warnings, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewEditRequest struct {
	ctx              context.Context
	ApiService       *DnsAPIService
	dnsViewEditInput *DnsViewEditInput
}

func (r ApiDnsViewEditRequest) DnsViewEditInput(dnsViewEditInput DnsViewEditInput) ApiDnsViewEditRequest {
	r.dnsViewEditInput = &dnsViewEditInput
	return r
}

func (r ApiDnsViewEditRequest) Execute() (*DnsViewEditSuccess, *http.Response, error) {
	return r.ApiService.DnsViewEditExecute(r)
}

/*
DnsViewEdit Edit a view

This service allows you to edit existing ones. A call can only edit one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id || (view_name && (server_id || server_name || server_hostaddr)))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewEditRequest
*/
func (a *DnsAPIService) DnsViewEdit(ctx context.Context) ApiDnsViewEditRequest {
	return ApiDnsViewEditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewEditSuccess
func (a *DnsAPIService) DnsViewEditExecute(r ApiDnsViewEditRequest) (*DnsViewEditSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/view/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewInfoRequest struct {
	ctx                context.Context
	ApiService         *DnsAPIService
	noParentClassParam *int32
	viewId             *int32
}

// A way to exclude the class parameter details of the parent of the object in the output parameter dedicated to its class parameters.
func (r ApiDnsViewInfoRequest) NoParentClassParam(noParentClassParam int32) ApiDnsViewInfoRequest {
	r.noParentClassParam = &noParentClassParam
	return r
}

// The database identifier (ID) of the DNS view. Use the ID to specify the DNS view of your choice.
func (r ApiDnsViewInfoRequest) ViewId(viewId int32) ApiDnsViewInfoRequest {
	r.viewId = &viewId
	return r
}

func (r ApiDnsViewInfoRequest) Execute() (*DnsViewData, *http.Response, error) {
	return r.ApiService.DnsViewInfoExecute(r)
}

/*
DnsViewInfo Display the properties of a view

This service allows you to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewInfoRequest
*/
func (a *DnsAPIService) DnsViewInfo(ctx context.Context) ApiDnsViewInfoRequest {
	return ApiDnsViewInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewData
func (a *DnsAPIService) DnsViewInfoExecute(r ApiDnsViewInfoRequest) (*DnsViewData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/view/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.noParentClassParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_parent_class_param", r.noParentClassParam, "form", "")
	}
	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewListRequest struct {
	ctx                context.Context
	ApiService         *DnsAPIService
	orderby            *string
	select_            *string
	where              *string
	limit              *int32
	offset             *int32
	noParentClassParam *int32
	tags               *string
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsViewListRequest) Orderby(orderby string) ApiDnsViewListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsViewListRequest) Select_(select_ string) ApiDnsViewListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsViewListRequest) Where(where string) ApiDnsViewListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsViewListRequest) Limit(limit int32) ApiDnsViewListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsViewListRequest) Offset(offset int32) ApiDnsViewListRequest {
	r.offset = &offset
	return r
}

// A way to exclude the class parameter details of the parent of the object in the output parameter dedicated to its class parameters.
func (r ApiDnsViewListRequest) NoParentClassParam(noParentClassParam int32) ApiDnsViewListRequest {
	r.noParentClassParam = &noParentClassParam
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsViewListRequest) Tags(tags string) ApiDnsViewListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsViewListRequest) Execute() (*DnsViewData, *http.Response, error) {
	return r.ApiService.DnsViewListExecute(r)
}

/*
DnsViewList List the views

This service allows you to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewListRequest
*/
func (a *DnsAPIService) DnsViewList(ctx context.Context) ApiDnsViewListRequest {
	return ApiDnsViewListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewData
func (a *DnsAPIService) DnsViewListExecute(r ApiDnsViewListRequest) (*DnsViewData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/view/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.noParentClassParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_parent_class_param", r.noParentClassParam, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewparamAddRequest struct {
	ctx                  context.Context
	ApiService           *DnsAPIService
	dnsViewparamAddInput *DnsViewparamAddInput
}

func (r ApiDnsViewparamAddRequest) DnsViewparamAddInput(dnsViewparamAddInput DnsViewparamAddInput) ApiDnsViewparamAddRequest {
	r.dnsViewparamAddInput = &dnsViewparamAddInput
	return r
}

func (r ApiDnsViewparamAddRequest) Execute() (*DnsViewparamAddSuccess, *http.Response, error) {
	return r.ApiService.DnsViewparamAddExecute(r)
}

/*
DnsViewparamAdd Add a DNS option on a view

This service allows you to add objects. A call can only add one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id && viewparam_key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewparamAddRequest
*/
func (a *DnsAPIService) DnsViewparamAdd(ctx context.Context) ApiDnsViewparamAddRequest {
	return ApiDnsViewparamAddRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewparamAddSuccess
func (a *DnsAPIService) DnsViewparamAddExecute(r ApiDnsViewparamAddRequest) (*DnsViewparamAddSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewparamAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewparamAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/viewparam/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewparamAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewparamAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewparamCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsViewparamCountRequest) Where(where string) ApiDnsViewparamCountRequest {
	r.where = &where
	return r
}

func (r ApiDnsViewparamCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsViewparamCountExecute(r)
}

/*
DnsViewparamCount Count the number of DNS options of a view

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewparamCountRequest
*/
func (a *DnsAPIService) DnsViewparamCount(ctx context.Context) ApiDnsViewparamCountRequest {
	return ApiDnsViewparamCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsViewparamCountExecute(r ApiDnsViewparamCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewparamCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/viewparam/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewparamDeleteRequest struct {
	ctx          context.Context
	ApiService   *DnsAPIService
	viewId       *int32
	viewparamKey *string
}

// The database identifier (ID) of the DNS view. Use the ID to specify the DNS view of your choice.
func (r ApiDnsViewparamDeleteRequest) ViewId(viewId int32) ApiDnsViewparamDeleteRequest {
	r.viewId = &viewId
	return r
}

// The name of the DNS option that you want to remove from the view: &lt;b&gt;param_key&#x3D;&amp;lt;option-name&amp;gt;&lt;/b&gt;.
func (r ApiDnsViewparamDeleteRequest) ViewparamKey(viewparamKey string) ApiDnsViewparamDeleteRequest {
	r.viewparamKey = &viewparamKey
	return r
}

func (r ApiDnsViewparamDeleteRequest) Execute() (*DnsViewparamDeleteSuccess, *http.Response, error) {
	return r.ApiService.DnsViewparamDeleteExecute(r)
}

/*
DnsViewparamDelete Delete a DNS option from a view

This service allows you to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id && viewparam_key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewparamDeleteRequest
*/
func (a *DnsAPIService) DnsViewparamDelete(ctx context.Context) ApiDnsViewparamDeleteRequest {
	return ApiDnsViewparamDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewparamDeleteSuccess
func (a *DnsAPIService) DnsViewparamDeleteExecute(r ApiDnsViewparamDeleteRequest) (*DnsViewparamDeleteSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewparamDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewparamDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/viewparam/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "form", "")
	}
	if r.viewparamKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewparam_key", r.viewparamKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewparamDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewparamEditRequest struct {
	ctx                   context.Context
	ApiService            *DnsAPIService
	dnsViewparamEditInput *DnsViewparamEditInput
}

func (r ApiDnsViewparamEditRequest) DnsViewparamEditInput(dnsViewparamEditInput DnsViewparamEditInput) ApiDnsViewparamEditRequest {
	r.dnsViewparamEditInput = &dnsViewparamEditInput
	return r
}

func (r ApiDnsViewparamEditRequest) Execute() (*DnsViewparamEditSuccess, *http.Response, error) {
	return r.ApiService.DnsViewparamEditExecute(r)
}

/*
DnsViewparamEdit Edit a DNS option on a view

This service allows you to edit existing ones. A call can only edit one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (view_id && viewparam_key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewparamEditRequest
*/
func (a *DnsAPIService) DnsViewparamEdit(ctx context.Context) ApiDnsViewparamEditRequest {
	return ApiDnsViewparamEditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewparamEditSuccess
func (a *DnsAPIService) DnsViewparamEditExecute(r ApiDnsViewparamEditRequest) (*DnsViewparamEditSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewparamEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewparamEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/viewparam/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsViewparamEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsViewparamEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewparamInfoRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	viewId     *int32
}

// The database identifier (ID) of the DNS view. Use the ID to specify the DNS view of your choice.
func (r ApiDnsViewparamInfoRequest) ViewId(viewId int32) ApiDnsViewparamInfoRequest {
	r.viewId = &viewId
	return r
}

func (r ApiDnsViewparamInfoRequest) Execute() (*DnsViewparamData, *http.Response, error) {
	return r.ApiService.DnsViewparamInfoExecute(r)
}

/*
DnsViewparamInfo Display the properties of a DNS option set on a view

This service allows you to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewparamInfoRequest
*/
func (a *DnsAPIService) DnsViewparamInfo(ctx context.Context) ApiDnsViewparamInfoRequest {
	return ApiDnsViewparamInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewparamData
func (a *DnsAPIService) DnsViewparamInfoExecute(r ApiDnsViewparamInfoRequest) (*DnsViewparamData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewparamInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/viewparam/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsViewparamListRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	orderby    *string
	select_    *string
	where      *string
	limit      *int32
	offset     *int32
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsViewparamListRequest) Orderby(orderby string) ApiDnsViewparamListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsViewparamListRequest) Select_(select_ string) ApiDnsViewparamListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsViewparamListRequest) Where(where string) ApiDnsViewparamListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsViewparamListRequest) Limit(limit int32) ApiDnsViewparamListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsViewparamListRequest) Offset(offset int32) ApiDnsViewparamListRequest {
	r.offset = &offset
	return r
}

func (r ApiDnsViewparamListRequest) Execute() (*DnsViewparamData, *http.Response, error) {
	return r.ApiService.DnsViewparamListExecute(r)
}

/*
DnsViewparamList List the DNS options of a view

This service allows you to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsViewparamListRequest
*/
func (a *DnsAPIService) DnsViewparamList(ctx context.Context) ApiDnsViewparamListRequest {
	return ApiDnsViewparamListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsViewparamData
func (a *DnsAPIService) DnsViewparamListExecute(r ApiDnsViewparamListRequest) (*DnsViewparamData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsViewparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsViewparamList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/viewparam/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneAddRequest struct {
	ctx             context.Context
	ApiService      *DnsAPIService
	dnsZoneAddInput *DnsZoneAddInput
}

func (r ApiDnsZoneAddRequest) DnsZoneAddInput(dnsZoneAddInput DnsZoneAddInput) ApiDnsZoneAddRequest {
	r.dnsZoneAddInput = &dnsZoneAddInput
	return r
}

func (r ApiDnsZoneAddRequest) Execute() (*DnsZoneAddSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneAddExecute(r)
}

/*
DnsZoneAdd Add a zone

This service allows you to add objects. A call can only add one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_name && zone_type && (view_id || view_name) && (server_id || server_name || server_hostaddr))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneAddRequest
*/
func (a *DnsAPIService) DnsZoneAdd(ctx context.Context) ApiDnsZoneAddRequest {
	return ApiDnsZoneAddRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneAddSuccess
func (a *DnsAPIService) DnsZoneAddExecute(r ApiDnsZoneAddRequest) (*DnsZoneAddSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zone/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
	tags       *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsZoneCountRequest) Where(where string) ApiDnsZoneCountRequest {
	r.where = &where
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsZoneCountRequest) Tags(tags string) ApiDnsZoneCountRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsZoneCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneCountExecute(r)
}

/*
DnsZoneCount Count the number of zones

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneCountRequest
*/
func (a *DnsAPIService) DnsZoneCount(ctx context.Context) ApiDnsZoneCountRequest {
	return ApiDnsZoneCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsZoneCountExecute(r ApiDnsZoneCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zone/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneDeleteRequest struct {
	ctx            context.Context
	ApiService     *DnsAPIService
	serverId       *int32
	serverName     *string
	viewId         *int32
	viewName       *string
	zoneId         *int32
	zoneName       *string
	serverHostaddr *string
	warnings       *string
}

// The database identifier (ID) of the DNS server, a unique numeric key value automatically incremented when you add a DNS server. Use the ID to specify the DNS server of your choice.
func (r ApiDnsZoneDeleteRequest) ServerId(serverId int32) ApiDnsZoneDeleteRequest {
	r.serverId = &serverId
	return r
}

// The name of the DNS server.
func (r ApiDnsZoneDeleteRequest) ServerName(serverName string) ApiDnsZoneDeleteRequest {
	r.serverName = &serverName
	return r
}

// The database identifier (ID) of the DNS view the object belongs to.
func (r ApiDnsZoneDeleteRequest) ViewId(viewId int32) ApiDnsZoneDeleteRequest {
	r.viewId = &viewId
	return r
}

// The name of the DNS view the object belongs to.
func (r ApiDnsZoneDeleteRequest) ViewName(viewName string) ApiDnsZoneDeleteRequest {
	r.viewName = &viewName
	return r
}

// The database identifier (ID) of the DNS zone, a unique numeric key value automatically incremented when you add a DNS zone. Use the ID to specify the DNS zone of your choice.
func (r ApiDnsZoneDeleteRequest) ZoneId(zoneId int32) ApiDnsZoneDeleteRequest {
	r.zoneId = &zoneId
	return r
}

// The name of the DNS zone the object belongs to.
func (r ApiDnsZoneDeleteRequest) ZoneName(zoneName string) ApiDnsZoneDeleteRequest {
	r.zoneName = &zoneName
	return r
}

// The IP address of the DNS server.
func (r ApiDnsZoneDeleteRequest) ServerHostaddr(serverHostaddr string) ApiDnsZoneDeleteRequest {
	r.serverHostaddr = &serverHostaddr
	return r
}

// A way to bypass &lt;b&gt;(accept) &lt;/b&gt;any enabled rule that would return warning messages. If the service returns an error message, you cannot bypass the enabled rules.
func (r ApiDnsZoneDeleteRequest) Warnings(warnings string) ApiDnsZoneDeleteRequest {
	r.warnings = &warnings
	return r
}

func (r ApiDnsZoneDeleteRequest) Execute() (*DnsZoneDeleteSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneDeleteExecute(r)
}

/*
DnsZoneDelete Delete a zone

This service allows you to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id || (zone_name && (view_id || (view_name && (server_id || server_name || server_hostaddr)))))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneDeleteRequest
*/
func (a *DnsAPIService) DnsZoneDelete(ctx context.Context) ApiDnsZoneDeleteRequest {
	return ApiDnsZoneDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneDeleteSuccess
func (a *DnsAPIService) DnsZoneDeleteExecute(r ApiDnsZoneDeleteRequest) (*DnsZoneDeleteSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zone/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_id", r.serverId, "form", "")
	}
	if r.serverName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_name", r.serverName, "form", "")
	}
	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "form", "")
	}
	if r.viewName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_name", r.viewName, "form", "")
	}
	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_id", r.zoneId, "form", "")
	}
	if r.zoneName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_name", r.zoneName, "form", "")
	}
	if r.serverHostaddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_hostaddr", r.serverHostaddr, "form", "")
	}
	if r.warnings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warnings", r.warnings, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneEditRequest struct {
	ctx              context.Context
	ApiService       *DnsAPIService
	dnsZoneEditInput *DnsZoneEditInput
}

func (r ApiDnsZoneEditRequest) DnsZoneEditInput(dnsZoneEditInput DnsZoneEditInput) ApiDnsZoneEditRequest {
	r.dnsZoneEditInput = &dnsZoneEditInput
	return r
}

func (r ApiDnsZoneEditRequest) Execute() (*DnsZoneEditSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneEditExecute(r)
}

/*
DnsZoneEdit Edit a zone

This service allows you to edit existing ones. A call can only edit one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id || (zone_name && (view_id || view_name) && (server_id || server_name || server_hostaddr)))

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneEditRequest
*/
func (a *DnsAPIService) DnsZoneEdit(ctx context.Context) ApiDnsZoneEditRequest {
	return ApiDnsZoneEditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneEditSuccess
func (a *DnsAPIService) DnsZoneEditExecute(r ApiDnsZoneEditRequest) (*DnsZoneEditSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zone/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneInfoRequest struct {
	ctx                context.Context
	ApiService         *DnsAPIService
	noParentClassParam *int32
	zoneId             *int32
}

// A way to exclude the class parameter details of the parent of the object in the output parameter dedicated to its class parameters.
func (r ApiDnsZoneInfoRequest) NoParentClassParam(noParentClassParam int32) ApiDnsZoneInfoRequest {
	r.noParentClassParam = &noParentClassParam
	return r
}

// The database identifier (ID) of the DNS zone, a unique numeric key value automatically incremented when you add a DNS zone. Use the ID to specify the DNS zone of your choice.
func (r ApiDnsZoneInfoRequest) ZoneId(zoneId int32) ApiDnsZoneInfoRequest {
	r.zoneId = &zoneId
	return r
}

func (r ApiDnsZoneInfoRequest) Execute() (*DnsZoneData, *http.Response, error) {
	return r.ApiService.DnsZoneInfoExecute(r)
}

/*
DnsZoneInfo Display the properties of a zone

This service allows you to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneInfoRequest
*/
func (a *DnsAPIService) DnsZoneInfo(ctx context.Context) ApiDnsZoneInfoRequest {
	return ApiDnsZoneInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneData
func (a *DnsAPIService) DnsZoneInfoExecute(r ApiDnsZoneInfoRequest) (*DnsZoneData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zone/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.noParentClassParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_parent_class_param", r.noParentClassParam, "form", "")
	}
	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_id", r.zoneId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneListRequest struct {
	ctx                context.Context
	ApiService         *DnsAPIService
	orderby            *string
	select_            *string
	where              *string
	limit              *int32
	offset             *int32
	noParentClassParam *int32
	tags               *string
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsZoneListRequest) Orderby(orderby string) ApiDnsZoneListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsZoneListRequest) Select_(select_ string) ApiDnsZoneListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsZoneListRequest) Where(where string) ApiDnsZoneListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsZoneListRequest) Limit(limit int32) ApiDnsZoneListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsZoneListRequest) Offset(offset int32) ApiDnsZoneListRequest {
	r.offset = &offset
	return r
}

// A way to exclude the class parameter details of the parent of the object in the output parameter dedicated to its class parameters.
func (r ApiDnsZoneListRequest) NoParentClassParam(noParentClassParam int32) ApiDnsZoneListRequest {
	r.noParentClassParam = &noParentClassParam
	return r
}

// The list of class parameters to tag in the call, separated by a comma. Each parameter must be specified following the format &lt;object-type&gt;.&lt;parameter&gt;, e.g. site.decription .
func (r ApiDnsZoneListRequest) Tags(tags string) ApiDnsZoneListRequest {
	r.tags = &tags
	return r
}

func (r ApiDnsZoneListRequest) Execute() (*DnsZoneData, *http.Response, error) {
	return r.ApiService.DnsZoneListExecute(r)
}

/*
DnsZoneList List the DNS options of a zone

This service allows you to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneListRequest
*/
func (a *DnsAPIService) DnsZoneList(ctx context.Context) ApiDnsZoneListRequest {
	return ApiDnsZoneListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneData
func (a *DnsAPIService) DnsZoneListExecute(r ApiDnsZoneListRequest) (*DnsZoneData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zone/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.noParentClassParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_parent_class_param", r.noParentClassParam, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneparamAddRequest struct {
	ctx                  context.Context
	ApiService           *DnsAPIService
	dnsZoneparamAddInput *DnsZoneparamAddInput
}

func (r ApiDnsZoneparamAddRequest) DnsZoneparamAddInput(dnsZoneparamAddInput DnsZoneparamAddInput) ApiDnsZoneparamAddRequest {
	r.dnsZoneparamAddInput = &dnsZoneparamAddInput
	return r
}

func (r ApiDnsZoneparamAddRequest) Execute() (*DnsZoneparamAddSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneparamAddExecute(r)
}

/*
DnsZoneparamAdd Add a DNS option on a zone

This service allows you to add objects. A call can only add one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id && zoneparam_key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneparamAddRequest
*/
func (a *DnsAPIService) DnsZoneparamAdd(ctx context.Context) ApiDnsZoneparamAddRequest {
	return ApiDnsZoneparamAddRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneparamAddSuccess
func (a *DnsAPIService) DnsZoneparamAddExecute(r ApiDnsZoneparamAddRequest) (*DnsZoneparamAddSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneparamAddSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneparamAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zoneparam/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneparamAddInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneparamAddFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneparamCountRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	where      *string
}

// A clause that allows you to filter the result. You can include any output parameter of the service &lt;object&gt;/list of the object in this clause.To filter the result using class parameters, you must tag them first.
func (r ApiDnsZoneparamCountRequest) Where(where string) ApiDnsZoneparamCountRequest {
	r.where = &where
	return r
}

func (r ApiDnsZoneparamCountRequest) Execute() (*ApiCountResponseSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneparamCountExecute(r)
}

/*
DnsZoneparamCount Count the number of DNS options of a zone

This service allows you to return the number of objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneparamCountRequest
*/
func (a *DnsAPIService) DnsZoneparamCount(ctx context.Context) ApiDnsZoneparamCountRequest {
	return ApiDnsZoneparamCountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiCountResponseSuccess
func (a *DnsAPIService) DnsZoneparamCountExecute(r ApiDnsZoneparamCountRequest) (*ApiCountResponseSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiCountResponseSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneparamCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zoneparam/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneparamDeleteRequest struct {
	ctx          context.Context
	ApiService   *DnsAPIService
	zoneId       *int32
	zoneparamKey *string
	serverId     *int32
}

// The database identifier (ID) of the DNS zone, a unique numeric key value automatically incremented when you add a DNS zone. Use the ID to specify the DNS zone of your choice.
func (r ApiDnsZoneparamDeleteRequest) ZoneId(zoneId int32) ApiDnsZoneparamDeleteRequest {
	r.zoneId = &zoneId
	return r
}

// The name of the DNS option that you want to remove from the zone: &lt;b&gt;param_key&#x3D;&amp;lt;option-name&amp;gt;&lt;/b&gt;.
func (r ApiDnsZoneparamDeleteRequest) ZoneparamKey(zoneparamKey string) ApiDnsZoneparamDeleteRequest {
	r.zoneparamKey = &zoneparamKey
	return r
}

// The database identifier (ID) of the DNS server, a unique numeric key value automatically incremented when you add a DNS server. Use the ID to specify the DNS server of your choice.
func (r ApiDnsZoneparamDeleteRequest) ServerId(serverId int32) ApiDnsZoneparamDeleteRequest {
	r.serverId = &serverId
	return r
}

func (r ApiDnsZoneparamDeleteRequest) Execute() (*DnsZoneparamDeleteSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneparamDeleteExecute(r)
}

/*
DnsZoneparamDelete Delete a DNS option from a zone

This service allows you to delete an object. A call can only delete one object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id && zoneparam_key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneparamDeleteRequest
*/
func (a *DnsAPIService) DnsZoneparamDelete(ctx context.Context) ApiDnsZoneparamDeleteRequest {
	return ApiDnsZoneparamDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneparamDeleteSuccess
func (a *DnsAPIService) DnsZoneparamDeleteExecute(r ApiDnsZoneparamDeleteRequest) (*DnsZoneparamDeleteSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneparamDeleteSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneparamDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zoneparam/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_id", r.zoneId, "form", "")
	}
	if r.zoneparamKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneparam_key", r.zoneparamKey, "form", "")
	}
	if r.serverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "server_id", r.serverId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneparamDeleteFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneparamEditRequest struct {
	ctx                   context.Context
	ApiService            *DnsAPIService
	dnsZoneparamEditInput *DnsZoneparamEditInput
}

func (r ApiDnsZoneparamEditRequest) DnsZoneparamEditInput(dnsZoneparamEditInput DnsZoneparamEditInput) ApiDnsZoneparamEditRequest {
	r.dnsZoneparamEditInput = &dnsZoneparamEditInput
	return r
}

func (r ApiDnsZoneparamEditRequest) Execute() (*DnsZoneparamEditSuccess, *http.Response, error) {
	return r.ApiService.DnsZoneparamEditExecute(r)
}

/*
DnsZoneparamEdit Edit a DNS option on a zone

This service allows you to edit existing ones. A call can only edit one object.<ul><li> If no identifier is specified, a new object is added.If an existing identifier is specified, the value of all the parameters specified in input edits the corresponding objects.To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.</br></br><b>Mandatory Parameters</b>: (zone_id && zoneparam_key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneparamEditRequest
*/
func (a *DnsAPIService) DnsZoneparamEdit(ctx context.Context) ApiDnsZoneparamEditRequest {
	return ApiDnsZoneparamEditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneparamEditSuccess
func (a *DnsAPIService) DnsZoneparamEditExecute(r ApiDnsZoneparamEditRequest) (*DnsZoneparamEditSuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneparamEditSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneparamEdit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zoneparam/edit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneparamEditInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DnsZoneparamEditFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneparamInfoRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	zoneId     *int32
}

// The database identifier (ID) of the DNS zone, a unique numeric key value automatically incremented when you add a DNS zone. Use the ID to specify the DNS zone of your choice.
func (r ApiDnsZoneparamInfoRequest) ZoneId(zoneId int32) ApiDnsZoneparamInfoRequest {
	r.zoneId = &zoneId
	return r
}

func (r ApiDnsZoneparamInfoRequest) Execute() (*DnsZoneparamData, *http.Response, error) {
	return r.ApiService.DnsZoneparamInfoExecute(r)
}

/*
DnsZoneparamInfo Display the properties of a DNS option set on a zone

This service allows you to display the properties of an object.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneparamInfoRequest
*/
func (a *DnsAPIService) DnsZoneparamInfo(ctx context.Context) ApiDnsZoneparamInfoRequest {
	return ApiDnsZoneparamInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneparamData
func (a *DnsAPIService) DnsZoneparamInfoExecute(r ApiDnsZoneparamInfoRequest) (*DnsZoneparamData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneparamInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zoneparam/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.zoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zone_id", r.zoneId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDnsZoneparamListRequest struct {
	ctx        context.Context
	ApiService *DnsAPIService
	orderby    *string
	select_    *string
	where      *string
	limit      *int32
	offset     *int32
}

// A clause that allows you to sort the result. You can include any output parameter of the service in this clause.To sort the result using class parameters, you must tag them first.You can add the optional keyword &lt;b&gt;ASC&lt;/b&gt; (ascending) or &lt;b&gt;DESC&lt;/b&gt; (descending) after each parameter. If not specified, &lt;b&gt;ASC&lt;/b&gt; is used by default. The order of the parameters specified is set using their value&#39;s name or ordinal number. Each parameter value is compared from one row to the next. If all the parameters of the rows are equal, they are returned in an implementation-dependent order.
func (r ApiDnsZoneparamListRequest) Orderby(orderby string) ApiDnsZoneparamListRequest {
	r.orderby = &orderby
	return r
}

// A statement that allows you to specify which column(s), i.e. parameter, is returned by the service.The statement can contain any output parameter of the service &lt;object&gt;/list.If you specify several parameters they must be separated by a comma as follows: &lt;b&gt;select&#x3D;&amp;lt;param1&amp;gt;&lt;b&gt;,&lt;/b&gt;&amp;lt;param2&amp;gt;&lt;b&gt;,&lt;/b&gt;...&lt;/b&gt; .If the call includes the clause &lt;b&gt;where&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.If the call includes the clause &lt;b&gt;orderby&lt;/b&gt;, all the parameters it contains must be specified in the statement &lt;b&gt;select&lt;/b&gt;.To include class parameters in the statement, you must tag them first.
func (r ApiDnsZoneparamListRequest) Select_(select_ string) ApiDnsZoneparamListRequest {
	r.select_ = &select_
	return r
}

// A clause that allows you to filter the result. You can include any output parameter of the service in this clause.To filter the result using class parameters, you must tag them first&lt;br/&gt;.The parameters and their value must be specified following the operators and syntax of the SQL standard, as in the following examples : &lt;b&gt;&amp;lt;parameter&amp;gt;&#x3D;&#39;&amp;lt;value&amp;gt;&#39;&lt;/b&gt; or &lt;b&gt;&amp;lt;parameter&amp;gt; IS NOT NULL&lt;/b&gt;. The clause is case insensitive and must be encoded in URL format.
func (r ApiDnsZoneparamListRequest) Where(where string) ApiDnsZoneparamListRequest {
	r.where = &where
	return r
}

// The maximum number of results to be returned. Depending on the user resources and the database content, it can return less results than the value you have specified.The input parameter &lt;b&gt;limit&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsZoneparamListRequest) Limit(limit int32) ApiDnsZoneparamListRequest {
	r.limit = &limit
	return r
}

// The number of rows to skip in the service output.The input parameter &lt;b&gt;offset&lt;/b&gt; must be specified in &lt;b&gt;lowercase&lt;/b&gt;.
func (r ApiDnsZoneparamListRequest) Offset(offset int32) ApiDnsZoneparamListRequest {
	r.offset = &offset
	return r
}

func (r ApiDnsZoneparamListRequest) Execute() (*DnsZoneparamData, *http.Response, error) {
	return r.ApiService.DnsZoneparamListExecute(r)
}

/*
DnsZoneparamList List the DNS options of a zone

This service allows you to list the objects.<br/>To execute this service, users must be granted the permission to use it. The rows returned to the user running the service depend on the resources granted to the group they belong to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDnsZoneparamListRequest
*/
func (a *DnsAPIService) DnsZoneparamList(ctx context.Context) ApiDnsZoneparamListRequest {
	return ApiDnsZoneparamListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DnsZoneparamData
func (a *DnsAPIService) DnsZoneparamListExecute(r ApiDnsZoneparamListRequest) (*DnsZoneparamData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DnsZoneparamData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsAPIService.DnsZoneparamList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dns/zoneparam/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderby != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderby", r.orderby, "form", "")
	}
	if r.select_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "select", r.select_, "form", "")
	}
	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderPasswordKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Password"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HttpHeaderLoginKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-IPM-Username"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["EipApiTokenTime"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-sds-ts"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
